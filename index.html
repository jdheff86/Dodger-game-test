<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="mobile-web-app-capable" content="yes">
<title>Dodger ‚Äî Leaderboard + Accounts + Power-Ups</title>
<style>
  :root {
    --bg:#0c0f14; --fg:#e9efff; --accent:#58a6ff; --danger:#ff6b6b;
    --muted:#8a94a6; --good:#4ade80; --gold:#ffd166; --gold-deep:#caa21e;
  }
  *{box-sizing:border-box}
  html,body{
    margin:0;height:100%;background:var(--bg);color:var(--fg);
    font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
    -webkit-font-smoothing:antialiased;-webkit-tap-highlight-color:transparent
  }
  body{overflow:hidden;touch-action:none;-webkit-user-select:none;user-select:none;-webkit-touch-callout:none}
  canvas{display:block;width:100%;height:100%}

  /* safe area + header layout */
  .safe{padding-top:env(safe-area-inset-top)}
  header{
    position:absolute;top:0;left:0;right:0;z-index:8;display:flex;flex-direction:column;gap:8px;
    padding:8px 10px;pointer-events:none
  }
  .row{display:flex;gap:8px;align-items:center;justify-content:space-between;flex-wrap:wrap}
  .row + .row{margin-top:6px}
  .left,.right{display:flex;gap:8px;align-items:center;flex-wrap:wrap}

  .hud,.btn{
    pointer-events:auto;background:rgba(255,255,255,0.06);border:1px solid rgba(255,255,255,0.12);
    border-radius:12px;padding:6px 10px
  }
  .hud{display:flex;gap:8px;align-items:center}
  .btn{font-weight:700}
  .btn:active{transform:translateY(1px)}
  #userChip{
    pointer-events:auto;background:rgba(88,166,255,0.18);border-color:rgba(88,166,255,0.4);
    border-radius:12px;padding:6px 10px;max-width:50vw
  }
  /* coin badge */
  #coinBadge{
    pointer-events:auto;display:flex;align-items:center;gap:6px;
    background:linear-gradient(180deg, rgba(255,209,102,0.25), rgba(202,162,30,0.18));
    border:1px solid rgba(255,209,102,0.35);
    padding:6px 10px;border-radius:12px
  }
  #coinBadge .dot{
    width:16px;height:16px;border-radius:50%;
    background:radial-gradient(circle at 35% 35%, #ffe694, #f3c64b 60%, #caa21e 100%);
    box-shadow:0 0 0 1px rgba(0,0,0,0.25) inset, 0 0 6px rgba(255, 210, 80, 0.35)
  }

  .controls{
    position:absolute;left:0;right:0;bottom:0;z-index:6;display:flex;justify-content:space-between;gap:12px;padding:14px;pointer-events:none
  }
  .pad{
    flex:1;min-height:92px;border-radius:16px;pointer-events:auto;
    background:linear-gradient(180deg,rgba(255,255,255,0.07),rgba(255,255,255,0.03));
    border:1px solid rgba(255,255,255,0.1);display:flex;align-items:center;justify-content:center
  }
  .pad span{font-size:28px;filter:drop-shadow(0 2px 0 rgba(0,0,0,0.35))}
  .pad.fire{flex:0.9}
  .ammo{color:var(--good);font-variant-numeric:tabular-nums}

  /* Ability bar (shrink activator) */
  #abilities{position:absolute;left:0;right:0;bottom:110px;display:flex;justify-content:center;z-index:6;pointer-events:none}
  #shrinkBtn{pointer-events:auto;display:flex;align-items:center;gap:8px}
  #shrinkCount{min-width:1.6em;text-align:center}

  .overlay{
    position:absolute;inset:0;z-index:7;display:flex;align-items:center;justify-content:center;
    background:radial-gradient(1200px 800px at 50% 40%, rgba(88,166,255,0.12), rgba(12,15,20,0.92) 60%);text-align:center;padding:24px
  }
  .card{max-width:560px;width:92%;background:rgba(255,255,255,0.08);border:1px solid rgba(255,255,255,0.14);border-radius:18px;padding:18px;backdrop-filter:blur(10px)}
  .title{font-size:26px;font-weight:800;margin:4px 0 10px}
  .subtitle{color:var(--muted);margin-bottom:14px}
  .go{margin-top:12px;width:100%;padding:12px 14px;font-weight:800;font-size:18px;border-radius:14px;border:none;color:#0b1220;background:var(--accent)}
  .muted{color:var(--muted);font-size:13px;margin-top:8px}

  .modal{position:absolute;inset:0;z-index:12;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,0.55);padding:18px}
  .panel{width:min(520px,92%);background:#121826;border:1px solid rgba(255,255,255,0.12);border-radius:16px;padding:16px;position:relative}
  .panel h2{margin:4px 0 12px;font-size:20px}
  .grid{display:grid;gap:10px}
  .grid input{width:100%;padding:10px;border-radius:10px;border:1px solid rgba(255,255,255,0.15);background:#0f141f;color:var(--fg)}
  .actions{display:flex;gap:10px;margin-top:8px;flex-wrap:wrap}
  .btn2{flex:1;padding:10px 12px;border-radius:12px;border:1px solid rgba(255,255,255,0.18);background:rgba(255,255,255,0.06);color:var(--fg);font-weight:700}
  .btn2.primary{background:var(--accent);color:#0b1220;border-color:transparent}
  .x{position:absolute;top:10px;right:12px;background:transparent;border:none;color:var(--muted);font-size:22px}
</style>
</head>
<body class="safe">
<canvas id="game" aria-label="Dodger game area"></canvas>

<header class="safe">
  <!-- Top row: HUD only -->
  <div class="row">
    <div class="left">
      <div class="hud"><strong>Score:</strong><span id="score">0</span></div>
      <div class="hud"><strong>Best:</strong><span id="best">0</span></div>
      <div class="hud"><strong>Ammo:</strong><span id="ammo" class="ammo">0</span></div>
      <div class="hud"><strong>Lives:</strong><span id="lives" class="ammo">0</span></div>
    </div>
    <div class="right"></div>
  </div>
  <!-- Second row: user + buttons + coin badge -->
  <div class="row">
    <div class="left">
      <div id="userChip">Connecting‚Ä¶</div>
      <div id="coinBadge" title="Your coins"><span class="dot"></span><strong id="coinCount">0</strong></div>
    </div>
    <div class="right">
      <button class="btn" id="lbBtn">Leaderboard</button>
      <button class="btn" id="nameBtn">Set name</button>
      <button class="btn" id="authBtn">Account</button>
      <button class="btn" id="pauseBtn" aria-label="Pause or resume">Pause</button>
    </div>
  </div>
</header>

<!-- Ability bar -->
<div id="abilities">
  <button id="shrinkBtn" class="btn">‚úÇ Shrink <span id="shrinkCount" class="ammo">0</span></button>
</div>

<!-- Controls -->
<div class="controls">
  <div class="pad" id="leftPad"><span>‚üµ</span></div>
  <div class="pad fire" id="firePad"><span>üî´ FIRE</span></div>
  <div class="pad" id="rightPad"><span>‚ü∂</span></div>
</div>

<!-- Start overlay -->
<div class="overlay" id="overlay">
  <div class="card">
    <div class="title">DODGER</div>
    <div class="subtitle">Avoid blocks. Power-ups: üî´ Blaster, ‚úÇ Shrink, üõ° Shield, üêå Slow, üß≤ Magnet, ‚ù§Ô∏è Life, ü™ô Coins.</div>
    <button class="go" id="startBtn">Start</button>
    <div class="muted">Tip: Add to Home Screen on iPhone for full-screen play.</div>
  </div>
</div>

<!-- Name modal -->
<div class="modal" id="nameModal">
  <div class="panel">
    <button class="x" id="nameClose">√ó</button>
    <h2>Set display name</h2>
    <div class="grid"><input id="displayName" type="text" maxlength="24" placeholder="e.g., JohnH"></div>
    <div class="actions">
      <button class="btn2" id="cancelName">Cancel</button>
      <button class="btn2 primary" id="saveName">Save</button>
    </div>
    <div class="muted">Used on the global leaderboard.</div>
  </div>
</div>

<!-- Leaderboard modal -->
<div class="modal" id="lbModal">
  <div class="panel">
    <button class="x" id="lbClose">√ó</button>
    <h2>Global Leaderboard (Top 20)</h2>
    <table id="lbTable" style="width:100%; border-collapse:collapse;">
      <thead><tr><th style="text-align:left;">#</th><th style="text-align:left;">Name</th><th>Score</th><th>When</th></tr></thead>
      <tbody></tbody>
    </table>
    <div class="muted">Finish a run to submit your score.</div>
  </div>
</div>

<!-- Account modal -->
<div class="modal" id="authModal">
  <div class="panel">
    <button class="x" id="authClose">√ó</button>
    <h2>Account</h2>
    <div id="authMsg" class="muted" style="min-height:18px;margin-bottom:8px;"></div>
    <div class="grid">
      <input id="authEmail" type="email" placeholder="Email">
      <input id="authPass" type="password" placeholder="Password (min 6)">
    </div>
    <div class="actions">
      <button class="btn2" id="authSignin">Sign in</button>
      <button class="btn2 primary" id="authSignup">Create account</button>
      <button class="btn2" id="authSignout">Sign out</button>
    </div>
  </div>
</div>

<!-- ===== Firebase (Auth + Firestore) ===== -->
<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-app.js";
  import {
    getAuth, onAuthStateChanged,
    signInWithEmailAndPassword, createUserWithEmailAndPassword,
    updateProfile, signOut
  } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-auth.js";
  import {
    getFirestore, collection, addDoc, query, orderBy, limit, getDocs, serverTimestamp,
    doc, getDoc, setDoc, updateDoc, increment
  } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-firestore.js";

  const firebaseConfig = {
    apiKey: "AIzaSyD37Lc_tHwEkmXSHwDr6QUTNeWXGOKAftg",
    authDomain: "dodger-4aad1.firebaseapp.com",
    projectId: "dodger-4aad1",
    storageBucket: "dodger-4aad1.appspot.com",
    messagingSenderId: "148070811748",
    appId: "1:148070811748:web:1ed51b4872b9d9106b3771",
    measurementId: "G-NV3R6CEYH7"
  };

  const app = initializeApp(firebaseConfig);
  const auth = getAuth(app);
  const db   = getFirestore(app);

  // expose small helper API
  window.firebase = {
    auth, db,
    onUser(cb){ return onAuthStateChanged(auth, cb); },
    async setDisplayName(name){
      if (!auth.currentUser) return;
      const clean = String(name||"Player").trim().slice(0,24);
      await updateProfile(auth.currentUser, { displayName: clean });
      return clean;
    },
    async ensureUserDoc(uid,email,displayName){
      const ref = doc(db,"users",uid);
      const snap = await getDoc(ref);
      if (!snap.exists()){
        await setDoc(ref, { coins: 0, email: email||null, name: displayName||null, createdAt: serverTimestamp() });
        return 0;
      }
      const d = snap.data()||{}; return Number(d.coins||0);
    },
    async addCoins(uid,n){
      const ref = doc(db,"users",uid);
      await updateDoc(ref, { coins: increment(n) });
      const cur = await getDoc(ref);
      return Number((cur.data()||{}).coins||0);
    },
    async getCoins(uid){
      const ref = doc(db,"users",uid); const s = await getDoc(ref);
      return Number((s.data()||{}).coins||0);
    },
    async saveScore(score){
      if (!auth.currentUser) return { ok:false, error:"Not signed in" };
      try{
        await addDoc(collection(db,"scores"),{
          uid:auth.currentUser.uid,
          name:auth.currentUser.displayName || auth.currentUser.email || "Player",
          score: Math.floor(Number(score)||0),
          ts: serverTimestamp()
        });
        return { ok:true };
      }catch(e){ return { ok:false, error:e.message }; }
    },
    async loadTop(n=20){
      const qy = query(collection(db,"scores"), orderBy("score","desc"), orderBy("ts","asc"), limit(n));
      const snap = await getDocs(qy);
      return snap.docs.map(d => ({ id:d.id, ...d.data() }));
    }
  };

  // auth UI wiring + force sign-in
  const userChip = document.getElementById("userChip");
  const coinCountEl = document.getElementById("coinCount");
  const authBtn = document.getElementById("authBtn");
  const authModal = document.getElementById("authModal");
  const authClose = document.getElementById("authClose");
  const authEmail = document.getElementById("authEmail");
  const authPass  = document.getElementById("authPass");
  const authMsg   = document.getElementById("authMsg");
  const btnIn     = document.getElementById("authSignin");
  const btnUp     = document.getElementById("authSignup");
  const btnOut    = document.getElementById("authSignout");

  function openModal(m){ m.style.display="flex"; }
  function closeModal(m){ m.style.display="none"; }
  document.querySelectorAll(".modal").forEach(m=>{
    m.addEventListener("pointerdown",(e)=>{ if(e.target===m) closeModal(m); },{passive:true});
  });
  document.addEventListener("keydown",(e)=>{ if(e.key==="Escape") document.querySelectorAll(".modal").forEach(m=>m.style.display="none"); });

  authBtn.addEventListener("pointerdown", e=>{ e.preventDefault(); openModal(authModal); });
  authClose.addEventListener("pointerdown", e=>{ e.preventDefault(); closeModal(authModal); });

  btnIn.addEventListener("pointerdown", async e=>{
    e.preventDefault(); authMsg.textContent="";
    try{
      const cred = await signInWithEmailAndPassword(auth, authEmail.value, authPass.value);
      await window.firebase.ensureUserDoc(cred.user.uid, cred.user.email, cred.user.displayName);
      closeModal(authModal);
    }catch(err){ authMsg.textContent = err.message; }
  });
  btnUp.addEventListener("pointerdown", async e=>{
    e.preventDefault(); authMsg.textContent="";
    try{
      const cred = await createUserWithEmailAndPassword(auth, authEmail.value, authPass.value);
      const def = (authEmail.value||"").split("@")[0].slice(0,24) || "Player";
      await updateProfile(cred.user,{displayName:def});
      await window.firebase.ensureUserDoc(cred.user.uid, cred.user.email, def);
      closeModal(authModal);
    }catch(err){ authMsg.textContent = err.message; }
  });
  btnOut.addEventListener("pointerdown", async e=>{ e.preventDefault(); await signOut(auth); openModal(authModal); });

  onAuthStateChanged(auth, async (u)=>{
    if(!u){ userChip.textContent="Not signed in"; openModal(authModal); return; }
    userChip.textContent = u.displayName ? `Signed in: ${u.displayName}` : (u.email ? `Signed in: ${u.email}` : "Signed in");
    const coins = await window.firebase.ensureUserDoc(u.uid, u.email, u.displayName);
    coinCountEl.textContent = coins|0;
  });
</script>

<!-- ===== Game code (incl. coin visuals) ===== -->
<script>
(function () {
  "use strict";

  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d", { alpha:false, desynchronized:true });

  let width=0, height=0, dpr=Math.max(1, window.devicePixelRatio||1);
  function fit(){
    width=Math.max(320,Math.floor(window.innerWidth||document.documentElement.clientWidth));
    height=Math.max(480,Math.floor(window.innerHeight||document.documentElement.clientHeight));
    dpr=Math.max(1, window.devicePixelRatio||1);
    canvas.width=Math.floor(width*dpr); canvas.height=Math.floor(height*dpr);
    canvas.style.width=width+"px"; canvas.style.height=height+"px";
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  fit(); window.addEventListener("resize", fit);

  // UI refs
  const scoreEl = document.getElementById("score");
  const bestEl  = document.getElementById("best");
  const ammoEl  = document.getElementById("ammo");
  const livesEl = document.getElementById("lives");
  const coinCountEl = document.getElementById("coinCount");
  const startBtn= document.getElementById("startBtn");
  const pauseBtn= document.getElementById("pauseBtn");
  const overlay = document.getElementById("overlay");
  const leftPad = document.getElementById("leftPad");
  const rightPad= document.getElementById("rightPad");
  const firePad = document.getElementById("firePad");
  const nameBtn = document.getElementById("nameBtn");
  const nameModal = document.getElementById("nameModal");
  const nameClose = document.getElementById("nameClose");
  const cancelName= document.getElementById("cancelName");
  const saveName  = document.getElementById("saveName");
  const nameInput = document.getElementById("displayName");
  const lbBtn = document.getElementById("lbBtn");
  const lbModal = document.getElementById("lbModal");
  const lbClose = document.getElementById("lbClose");
  const lbBody = document.querySelector("#lbTable tbody");
  const shrinkBtn = document.getElementById("shrinkBtn");
  const shrinkCountEl = document.getElementById("shrinkCount");

  const prevent=(e)=>{ if (e.target.closest(".overlay") || e.target.closest(".modal")) return; e.preventDefault(); };
  ["touchstart","touchmove","touchend","gesturestart"].forEach(ev=>document.addEventListener(ev, prevent, { passive:false }));

  // Name modal
  nameBtn.addEventListener("pointerdown", e=>{ e.preventDefault(); nameModal.style.display="flex"; });
  [nameClose,cancelName].forEach(el=>el.addEventListener("pointerdown", e=>{ e.preventDefault(); nameModal.style.display="none"; }));
  saveName.addEventListener("pointerdown", async e=>{
    e.preventDefault();
    const dn = await window.firebase?.setDisplayName?.(nameInput.value||"Player");
    if (dn) { const uc=document.getElementById("userChip"); uc.textContent = `Signed in: ${dn}`; }
    nameModal.style.display="none";
  });

  // Leaderboard modal
  lbBtn.addEventListener("pointerdown", async e=>{
    e.preventDefault();
    lbBody.innerHTML = "<tr><td colspan='4'>Loading‚Ä¶</td></tr>";
    try{
      const rows = await window.firebase.loadTop(20);
      if (!rows.length) { lbBody.innerHTML = "<tr><td colspan='4'>No scores yet.</td></tr>"; }
      else {
        let i=1; lbBody.innerHTML = rows.map(r=>{
          const when = r.ts?.toDate ? r.ts.toDate() : new Date();
          return `<tr><td>${i++}</td><td>${escapeHtml(r.name||"Player")}</td><td style="text-align:right">${r.score|0}</td><td>${when.toLocaleDateString()}</td></tr>`;
        }).join("");
      }
    }catch(err){ lbBody.innerHTML = `<tr><td colspan="4">Error: ${escapeHtml(err.message||String(err))}</td></tr>`; }
    lbModal.style.display="flex";
  });
  lbClose.addEventListener("pointerdown", e=>{ e.preventDefault(); lbModal.style.display="none"; });
  function escapeHtml(x){ return (x||"").replace(/[&<>"']/g, m=>({ "&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#39;" }[m])); }

  // Game state
  const state = {
    running:false, paused:false, over:false,
    score:0, best:Number(localStorage.getItem("dodger_best")||0),
    time:0, last:performance.now(),
    player:{ x:0, y:0, w:48, h:48, speed:420, vx:0, scale:1, invUntil:0 },
    blocks:[], blockTimer:0, difficulty:1,
    input:{ left:false, right:false, swipeVX:0 },
    bullets:[],
    ammo:0, lives:0, shrinkCharges:0,
    powerups:[], powTimer:2.5,
    coinsSpawnTimer: 3,
    effects:{ shrinkUntil:0, shieldUntil:0, slowUntil:0, magnetUntil:0 },
    coinsThisRun: 0
  };
  bestEl.textContent = state.best; ammoEl.textContent = state.ammo; livesEl.textContent = state.lives; shrinkCountEl.textContent = state.shrinkCharges;

  function resetPlayer(){
    const base = Math.max(36, Math.min(56, Math.floor(Math.min(width,height)*0.06)));
    state.player.w = base; state.player.h = base;
    state.player.x = (width - state.player.w)/2; state.player.y = height - state.player.h - 22; state.player.vx = 0; state.player.scale=1;
  }
  resetPlayer();

  // Input
  function bindPad(el,dir){ const down=(e)=>{ e.preventDefault(); if(dir<0) state.input.left=true; else state.input.right=true; };
    const up=(e)=>{ if(dir<0) state.input.left=false; else state.input.right=false; };
    el.addEventListener("pointerdown", down); el.addEventListener("pointerup", up);
    el.addEventListener("pointercancel", up); el.addEventListener("pointerleave", up); }
  bindPad(leftPad,-1); bindPad(rightPad,1);

  let swipeActive=false, swipeStartX=0;
  canvas.addEventListener("pointerdown", e=>{ swipeActive=true; swipeStartX=e.clientX; });
  window.addEventListener("pointermove", e=>{ if(!swipeActive) return; const dx=e.clientX-swipeStartX; state.input.swipeVX=dx*3; });
  window.addEventListener("pointerup", ()=>{ swipeActive=false; state.input.swipeVX=0; });

  firePad.addEventListener("pointerdown", e=>{ e.preventDefault(); shoot(); });
  shrinkBtn.addEventListener("pointerdown", e=>{ e.preventDefault(); useShrink(); });

  window.addEventListener("keydown", e=>{
    if(e.key==="ArrowLeft"||e.key==="a") state.input.left=true;
    if(e.key==="ArrowRight"||e.key==="d") state.input.right=true;
    if(e.key===" "){ e.preventDefault(); shoot(); }
    if(e.key==="Shift"){ e.preventDefault(); useShrink(); }
  });
  window.addEventListener("keyup", e=>{
    if(e.key==="ArrowLeft"||e.key==="a") state.input.left=false;
    if(e.key==="ArrowRight"||e.key==="d") state.input.right=false;
  });

  startBtn.addEventListener("pointerdown", e=>{ e.preventDefault(); startGame(); });
  pauseBtn.addEventListener("pointerdown", e=>{ e.preventDefault(); togglePause(); });

  function startGame(){
    state.blocks.length=0; state.bullets.length=0; state.powerups.length=0;
    state.score=0; state.time=0; state.blockTimer=0; state.powTimer=2.5; state.coinsSpawnTimer=2.5;
    state.difficulty=1; state.over=false; state.paused=false; state.coinsThisRun=0;
    state.effects = { shrinkUntil:0, shieldUntil:0, slowUntil:0, magnetUntil:0 };
    state.player.invUntil = 0;
    state.ammo=0; state.shrinkCharges=0; state.lives=0;
    ammoEl.textContent="0"; livesEl.textContent="0"; shrinkCountEl.textContent="0";
    resetPlayer();
    overlay.style.display="none"; state.running=true; state.last=performance.now();
    requestAnimationFrame(loop);
  }

  async function gameOver(){
    state.over=true; state.running=false; overlay.style.display="flex";
    overlay.querySelector(".title").textContent = "Game Over";
    const old = overlay.querySelector(".subtitle"); if (old) old.remove();
    const p = document.createElement("div"); p.className="subtitle";
    p.innerHTML = `You scored <strong>${Math.floor(state.score)}</strong>. ${(state.score>state.best)?`<span style="color:var(--danger)">New high score!</span>`:`Try again!`}`;
    overlay.querySelector(".card").insertBefore(p, overlay.querySelector(".go"));
    state.best=Math.max(state.best, Math.floor(state.score)); localStorage.setItem("dodger_best", String(state.best)); bestEl.textContent=state.best; startBtn.textContent="Play Again";
    if (window.firebase?.saveScore) { try { await window.firebase.saveScore(state.score); } catch(_){} }
    // persist coins earned this run
    const u = window.firebase?.auth?.currentUser;
    if (u && state.coinsThisRun>0){
      try{
        const total = await window.firebase.addCoins(u.uid, state.coinsThisRun);
        coinCountEl.textContent = total|0;
      }catch(_){}
    }
  }

  function togglePause(){
    if(!state.running || state.over) return;
    state.paused=!state.paused; pauseBtn.textContent = state.paused ? "Resume" : "Pause";
    if(!state.paused){ state.last=performance.now(); requestAnimationFrame(loop); }
    else { ctx.save(); ctx.fillStyle="rgba(0,0,0,0.25)"; ctx.fillRect(0,0,width,height); ctx.fillStyle="rgba(255,255,255,0.85)";
      ctx.font="700 20px system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif"; ctx.textAlign="center"; ctx.fillText("Paused", width/2, height*0.45); ctx.restore(); }
  }

  // Helpers
  function rand(min,max){ return Math.random()*(max-min)+min; }
  function roundRect(ctx,x,y,w,h,r,fill){ ctx.beginPath(); const rr=Math.min(r,w/2,h/2);
    ctx.moveTo(x+rr,y); ctx.arcTo(x+w,y, x+w,y+h, rr); ctx.arcTo(x+w,y+h, x,y+h, rr);
    ctx.arcTo(x,y+h, x,y, rr); ctx.arcTo(x,y, x+w,y, rr); ctx.closePath(); if(fill) ctx.fill(); }

  // Spawners
  function spawnBlock(){
    const size = rand(Math.max(22,width*0.03), Math.max(38,width*0.07));
    const x = rand(0, width - size);
    const speed = rand(140, 190) * state.difficulty;
    state.blocks.push({ x, y:-size, w:size, h:size, vy:speed });
  }
  function spawnPowerup(){
    const r = Math.random()*100;
    let type = "blaster";
    if (r<30) type="blaster";
    else if (r<50) type="shrink";
    else if (r<65) type="shield";
    else if (r<80) type="slow";
    else if (r<90) type="magnet";
    else type="life";
    const size = Math.max(26, Math.floor(Math.min(width,height)*0.05));
    const x = rand(0, width - size);
    const vy = rand(90, 130);
    state.powerups.push({ kind:"power", type, x, y:-size, w:size, h:size, vy });
  }
  function spawnCoin(){
    const r = Math.max(18, Math.floor(Math.min(width,height)*0.035));
    const x = rand(r+4, width-r-4);
    const vy = rand(100, 140);
    state.powerups.push({ kind:"coin", x, y:-r*2, r, vy, phase: Math.random()*Math.PI*2 });
  }

  // Actions
  function shoot(){
    if (state.ammo <= 0 || state.over || !state.running) return;
    state.ammo--; ammoEl.textContent = state.ammo;
    const p = state.player, cx = p.x + (p.w*p.scale)/2 - 4;
    state.bullets.push({ x: cx, y: p.y - 6, w: 8, h: 14, vy: -620 });
  }
  function useShrink(){
    if (state.shrinkCharges <= 0 || state.over || !state.running) return;
    state.shrinkCharges--; shrinkCountEl.textContent = state.shrinkCharges;
    state.effects.shrinkUntil = Math.max(state.effects.shrinkUntil, state.time) + 6; // stack duration
  }

  // Update & draw
  function update(dt){
    state.time += dt;
    state.score += dt*10; scoreEl.textContent = Math.floor(state.score);
    state.difficulty = 1 + Math.min(2.2, state.time/24);

    const slowActive = state.effects.slowUntil > state.time;
    const worldDT = dt * (slowActive ? 0.55 : 1);

    state.player.scale = (state.effects.shrinkUntil > state.time) ? 0.6 : 1;

    const p = state.player, base = p.speed * state.difficulty * 0.95;
    let targetVX = 0;
    if(state.input.left) targetVX -= base;
    if(state.input.right) targetVX += base;
    targetVX += state.input.swipeVX;
    p.vx += (targetVX - p.vx) * Math.min(1, dt*10);
    p.x += p.vx * dt;
    const pw = p.w * p.scale, ph = p.h * p.scale;
    if (p.x < 0) { p.x = 0; p.vx = Math.max(0, p.vx); }
    if (p.x + pw > width) { p.x = width - pw; p.vx = Math.min(0, p.vx); }

    // spawn blocks
    state.blockTimer -= worldDT;
    const interval = Math.max(0.22, 0.9 - state.time*0.03);
    if (state.blockTimer <= 0) {
      spawnBlock();
      if (state.time > 12 && Math.random() < 0.35) spawnBlock();
      state.blockTimer = interval;
    }

    // spawn powerups
    state.powTimer -= worldDT;
    if (state.powTimer <= 0) { spawnPowerup(); state.powTimer = rand(8, 13); }

    // spawn coins
    state.coinsSpawnTimer -= worldDT;
    if (state.coinsSpawnTimer <= 0){
      spawnCoin();
      state.coinsSpawnTimer = rand(3.5, 6.5);
    }

    // move blocks
    for (let i=state.blocks.length-1; i>=0; i--) {
      const b = state.blocks[i]; b.y += b.vy * worldDT;
      if (b.y - b.h > height + 8) { state.blocks.splice(i,1); continue; }
    }

    // move coins/powerups (+magnet affects only powerups)
    const magnet = state.effects.magnetUntil > state.time;
    for (let i=state.powerups.length-1; i>=0; i--) {
      const u = state.powerups[i];
      if (u.kind==="coin"){
        u.y += u.vy * worldDT;
        u.phase += worldDT * 3.2; // spin speed
        if (u.y - u.r > height + 8) { state.powerups.splice(i,1); continue; }
        // collect coin
        if (circleRectOverlap(u.x, u.y, u.r*0.7, p.x, p.y, pw, ph)){
          state.powerups.splice(i,1);
          state.coinsThisRun += 1;
        }
        continue;
      }
      // powerup kinds
      if (magnet) {
        const cx = (p.x + pw/2) - (u.x + u.w/2);
        const cy = (p.y + ph/2) - (u.y + u.h/2);
        const dist = Math.max(1, Math.hypot(cx, cy));
        u.x += (cx/dist) * 220 * worldDT;
        u.y += (cy/dist) * 220 * worldDT;
      } else {
        u.y += u.vy * worldDT;
      }
      if (u.y - u.h > height + 8) { state.powerups.splice(i,1); continue; }
      // collect powerup
      if (u.x < p.x + pw && u.x + u.w > p.x && u.y < p.y + ph && u.y + u.h > p.y) {
        if (u.type === "blaster") { state.ammo += 6; ammoEl.textContent = state.ammo; }
        else if (u.type === "shrink") { state.shrinkCharges += 1; shrinkCountEl.textContent = state.shrinkCharges; }
        else if (u.type === "shield") { state.effects.shieldUntil = Math.max(state.effects.shieldUntil, state.time) + 6; }
        else if (u.type === "slow")   { state.effects.slowUntil   = Math.max(state.effects.slowUntil,   state.time) + 6; }
        else if (u.type === "magnet") { state.effects.magnetUntil = Math.max(state.effects.magnetUntil, state.time) + 8; }
        else if (u.type === "life")   { state.lives += 1; livesEl.textContent = state.lives; }
        state.powerups.splice(i,1);
      }
    }

    // bullets
    for (let i=state.bullets.length-1; i>=0; i--) {
      const bullet = state.bullets[i]; bullet.y += bullet.vy * dt;
      if (bullet.y + bullet.h < -10) { state.bullets.splice(i,1); continue; }
      for (let j=state.blocks.length-1; j>=0; j--) {
        const b = state.blocks[j];
        if (bullet.x < b.x + b.w && bullet.x + bullet.w > b.x && bullet.y < b.y + b.h && bullet.y + bullet.h > b.y) {
          state.blocks.splice(j,1);
          state.bullets.splice(i,1);
          state.score += 5;
          break;
        }
      }
    }

    // block vs player
    for (let i=state.blocks.length-1; i>=0; i--) {
      const b = state.blocks[i];
      const pw2 = pw, ph2 = ph;
      if (b.x < p.x + pw2 && b.x + b.w > p.x && b.y < p.y + ph2 && b.y + b.h > p.y) {
        if (state.player.invUntil > state.time) { state.blocks.splice(i,1); continue; }
        const shield = state.effects.shieldUntil > state.time;
        if (shield) {
          state.effects.shieldUntil = Math.max(state.time, state.effects.shieldUntil - 0.5);
          state.player.invUntil = state.time + 0.5;
          state.blocks.splice(i,1);
          continue;
        }
        if (state.lives > 0) {
          state.lives--; livesEl.textContent = state.lives;
          state.player.invUntil = state.time + 1.2;
          state.blocks.splice(i,1);
          continue;
        }
        gameOver(); return;
      }
    }

    // live coin counter UI: coins earned this run are shown as +local (total updates after run)
    if (state.coinsThisRunUI !== state.coinsThisRun){
      // show current total = accountTotal + runCoins (we don't know account total delta here; just show run coins next to counter)
      // simplest: show account total only; user will see increase after game over persists.
    }
  }

  function draw(){
    // background
    const g = ctx.createLinearGradient(0,0,0,height); g.addColorStop(0,"#0b1220"); g.addColorStop(1,"#0c0f14");
    ctx.fillStyle = g; ctx.fillRect(0,0,width,height);
    ctx.globalAlpha = 0.08; ctx.strokeStyle = "#8ab4ff"; ctx.lineWidth = 1;
    const grid = Math.max(20, Math.floor(Math.min(width, height)*0.04));
    ctx.beginPath(); for(let x=(width%grid); x<width; x+=grid){ ctx.moveTo(x,0); ctx.lineTo(x,height); }
    for(let y=(height%grid); y<height; y+=grid){ ctx.moveTo(0,y); ctx.lineTo(width,y); } ctx.stroke(); ctx.globalAlpha = 1;

    const p = state.player, pw = p.w*p.scale, ph = p.h*p.scale;

    // shield aura
    if (state.effects.shieldUntil > state.time) {
      ctx.save();
      ctx.globalAlpha = 0.25 + 0.15*Math.sin(state.time*8);
      ctx.fillStyle = "#4ade80";
      roundRect(ctx, p.x-6, p.y-6, pw+12, ph+12, Math.min(16, pw*0.35), true);
      ctx.restore();
    }
    // i-frames flash
    if (state.player.invUntil > state.time) { ctx.globalAlpha = 0.6 + 0.4*Math.sin(state.time*30); }
    // player
    ctx.fillStyle = "#58a6ff"; roundRect(ctx, p.x, p.y, pw, ph, Math.min(10, pw*0.25), true);
    ctx.globalAlpha = 1;

    // blocks
    for (const b of state.blocks) {
      ctx.fillStyle = "#ff6b6b";
      roundRect(ctx, b.x, b.y, b.w, b.h, Math.min(10, b.w*0.25), true);
      ctx.globalAlpha = 0.15; ctx.fillStyle = "#ffffff";
      roundRect(ctx, b.x+b.w*0.1, b.y+b.h*0.08, b.w*0.8, b.h*0.18, 8, true); ctx.globalAlpha = 1;
    }

    // power-ups and coins
    for (const u of state.powerups) {
      if (u.kind==="coin"){
        drawCoin(u.x, u.y, u.r, u.phase);
        continue;
      }
      let color="#ffd166", glyph="üî´";
      if (u.type==="shrink"){ color="#34d399"; glyph="‚úÇ"; }
      else if (u.type==="shield"){ color="#4ade80"; glyph="üõ°"; }
      else if (u.type==="slow"){ color="#60a5fa"; glyph="üêå"; }
      else if (u.type==="magnet"){ color="#f472b6"; glyph="üß≤"; }
      else if (u.type==="life"){ color="#f87171"; glyph="‚ù§Ô∏è"; }
      ctx.fillStyle = color; roundRect(ctx, u.x, u.y, u.w, u.h, 10, true);
      ctx.fillStyle = "rgba(0,0,0,0.25)";
      ctx.font = "700 14px system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial";
      ctx.textAlign = "center"; ctx.fillText(glyph, u.x+u.w/2, u.y+u.h/2+6);
    }

    // bullets
    ctx.fillStyle = "#f8fafc";
    for (const b of state.bullets) roundRect(ctx, b.x, b.y, b.w, b.h, 4, true);
  }

  // === Fancy coin renderer ===
  function drawCoin(cx, cy, r, t){
    ctx.save();

    // "spin": squash horizontally with phase t
    const squash = 0.82 + 0.18*Math.abs(Math.sin(t)); // 0.82..1.0
    ctx.translate(cx, cy);
    ctx.scale(squash, 1); // ellipse

    // base fill gradient (bright center)
    const grad = ctx.createRadialGradient(0, 0, r*0.2, 0, 0, r);
    grad.addColorStop(0, "#ffe894");
    grad.addColorStop(0.55, "#f3c64b");
    grad.addColorStop(1, "#caa21e");
    ctx.fillStyle = grad;
    ctx.beginPath(); ctx.arc(0, 0, r, 0, Math.PI*2); ctx.fill();

    // rim (darker ring)
    ctx.lineWidth = Math.max(1.5, r*0.08);
    ctx.strokeStyle = "rgba(120, 80, 10, 0.55)";
    ctx.beginPath(); ctx.arc(0, 0, r*0.92, 0, Math.PI*2); ctx.stroke();

    // knurling ticks around edge (alternating light/dark)
    const ticks = Math.max(16, Math.floor(r*1.6));
    for (let i=0;i<ticks;i++){
      const a = (i/ticks)*Math.PI*2 + t*1.2; // slow rotate so ridges appear to spin
      const inner = r*0.86, outer = r*0.98;
      const x1 = Math.cos(a)*inner, y1 = Math.sin(a)*inner;
      const x2 = Math.cos(a)*outer, y2 = Math.sin(a)*outer;
      ctx.strokeStyle = (i%2===0) ? "rgba(255,255,255,0.55)" : "rgba(90,60,10,0.55)";
      ctx.lineWidth = Math.max(1, r*0.04);
      ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
    }

    // specular highlight sweep
    ctx.rotate(0.6);
    const shine = ctx.createLinearGradient(-r, -r, r, r);
    shine.addColorStop(0, "rgba(255,255,255,0.0)");
    shine.addColorStop(0.45, "rgba(255,255,255,0.0)");
    shine.addColorStop(0.5, "rgba(255,255,255,"+(0.25+0.15*Math.sin(t*2))+")");
    shine.addColorStop(0.55, "rgba(255,255,255,0.0)");
    shine.addColorStop(1, "rgba(255,255,255,0.0)");
    ctx.fillStyle = shine;
    ctx.beginPath(); ctx.arc(0,0,r*0.96, 0, Math.PI*2); ctx.fill();

    ctx.restore();
  }

  function circleRectOverlap(cx, cy, cr, rx, ry, rw, rh){
    // clamp circle center to rect
    const x = Math.max(rx, Math.min(cx, rx+rw));
    const y = Math.max(ry, Math.min(cy, ry+rh));
    const dx = cx - x, dy = cy - y;
    return (dx*dx + dy*dy) <= cr*cr;
  }

  function loop(now){
    if (!state.running || state.paused || state.over) return;
    const dt = Math.min(0.033, (now - state.last)/1000);
    state.last = now;
    update(dt); draw();
    requestAnimationFrame(loop);
  }

  // first paint
  draw();
})();
</script>
</body>
</html>