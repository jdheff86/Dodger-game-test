<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum=1, user-scalable=no" />
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="mobile-web-app-capable" content="yes">
<title>Dodger — Leaderboard + Accounts + Power-Ups</title>
<style>
  :root { --bg:#0c0f14; --fg:#e9efff; --accent:#58a6ff; --danger:#ff6b6b; --muted:#8a94a6; --good:#4ade80; }

  * { box-sizing:border-box; }
  html, body { margin:0; height:100%; background:var(--bg); color:var(--fg);
    font-family: system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
    -webkit-font-smoothing:antialiased; -webkit-tap-highlight-color:transparent; }
  body { overflow:hidden; touch-action:none; -webkit-user-select:none; user-select:none; -webkit-touch-callout:none; }
  canvas { display:block; width:100%; height:100%; }
  .safe { padding-top: env(safe-area-inset-top); }

  /* HUD -*/
  header { position:absolute; top:0; left:0; right:0; z-index:8; display:flex; flex-direction:column; padding:8px 10px; gap:6px; pointer-events:none; }
  /* allow clicking inside the menu popup */
#menuPopup,
#menuPopup .menuItem {
  pointer-events: auto;
}
  #hud { --s:0.82; }
  
  /* ── HUD scaling across devices ─────────────────────────────────────────── */
#hud { --s:0.82; }                 /* default */
@media (max-width:380px){ #hud{ --s:0.72; } }               /* very small */
@media (min-width:381px) and (max-width:430px){ #hud{ --s:0.80; } } /* common */
@media (min-width:431px){ #hud{ --s:0.90; } }               /* large phones */

/* keep right chip row on one line; swipe to scroll if cramped */
header .toolbar .right{
  flex-wrap:nowrap;
  overflow-x:auto;
  -webkit-overflow-scrolling:touch;
  scrollbar-width:none;
}
header .toolbar .right::-webkit-scrollbar{ display:none; }

/* small gap between the two toolbar rows */
header .toolbar{ row-gap:calc(6px*var(--s)); }

/* minimum tap size for chips */
.btn,#coinChip,.hud{
  min-height:calc(28px*var(--s));
  padding:calc(6px*var(--s)) calc(10px*var(--s));
}

/* ── Menu (gear) dropdown ──────────────────────────────────────────────── */
#menuBtn svg{ vertical-align:-2px; }
#menuPopup{
  position:absolute; z-index:12010; display:none;
  background:rgba(18,24,38,.98);
  border:1px solid rgba(255,255,255,.14);
  border-radius:12px; padding:8px; min-width:170px;
  box-shadow:0 10px 24px rgba(0,0,0,.35);
}
#menuPopup .menuItem{
  width:100%; text-align:left; margin:0; padding:10px 12px;
  border-radius:10px; border:1px solid rgba(255,255,255,.12);
  background:rgba(255,255,255,.04); color:var(--fg); font-weight:700;
}
#menuPopup .menuItem + .menuItem{ margin-top:8px; }

/* hide the original toolbar chips we’re moving into the menu */
.hideOnToolbar{ display:none; }
  .topbar,.toolbar{ display:flex; align-items:center; justify-content:space-between; gap:calc(8px*var(--s)); height:calc(44px*var(--s)); flex-wrap:nowrap; }
  .left,.right{ display:flex; gap:calc(8px*var(--s)); align-items:center; min-width:0; }
  /* Put Store under the coin chip on the left side of the toolbar */
header .toolbar .left{
  flex-direction:column;
  align-items:flex-start;
}
/* Make the toolbar allow tidy wrapping + consistent row gap */
header .toolbar{
  align-items:flex-start;       /* align rows to the top */
  flex-wrap:wrap;               /* allow chips to wrap to a new line */
  row-gap:calc(6px*var(--s));   /* vertical space between wrapped rows */
}

/* Right side: lay chips out in rows that wrap nicely */
header .toolbar .right{
  flex:1 1 auto;
  min-width:0;
  display:flex;
  flex-wrap:wrap;                      /* allow multiple rows */
  gap:calc(8px*var(--s));              /* same horizontal gap as topbar */
  justify-content:flex-start;          /* left-align on small screens */
}

/* Keep each chip at its natural width */
header .toolbar .right > .btn{
  flex:0 0 auto;
}

/* On wider screens, keep them in one line and push to the right */
@media (min-width: 680px){
  header .toolbar{ flex-wrap:nowrap; }
  header .toolbar .right{ flex-wrap:nowrap; justify-content:flex-end; }
}

/* Slight downscale on very small phones so more chips fit per row */
@media (max-width: 380px){
  #hud{ --s:0.76; }   /* you had 0.82; this makes chips a touch smaller */
}
  .hud,.btn,#userChip,#coinChip{ pointer-events:auto; background:rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.12);
    border-radius:calc(12px*var(--s)); padding:calc(6px*var(--s)) calc(10px*var(--s)); white-space:nowrap; font-size:calc(14px*var(--s)); line-height:1; }
  .hud{ display:flex; gap:calc(8px*var(--s)); align-items:center; }
  .hud strong{ font-weight:800; }
  .btn{ font-weight:700; }
  .btn:active{ transform:translateY(1px); }
  #userChip{ background:rgba(88,166,255,.18); border-color:rgba(88,166,255,.4); max-width:66vw; overflow:hidden; text-overflow:ellipsis; }
  .ammo{ color:var(--good); font-variant-numeric:tabular-nums; }
  #coinChip{ display:flex; align-items:center; gap:calc(6px*var(--s)); background:rgba(255,213,95,.12); border-color:rgba(255,213,95,.35); }
  #coinChip svg{ width:calc(18px*var(--s)); height:calc(18px*var(--s)); flex:0 0 auto; }

  /* Controls / overlay / modals */
  .controls{ position:absolute; left:0; right:0; bottom:0; z-index:6; display:flex; justify-content:space-between; gap:12px; padding:14px; pointer-events:none; }
  .pad{ flex:1; min-height:92px; border-radius:16px; pointer-events:auto; background:linear-gradient(180deg,rgba(255,255,255,.07),rgba(255,255,255,.03)); border:1px solid rgba(255,255,255,.1); display:flex; align-items:center; justify-content:center; }
  .pad span{ font-size:28px; filter:drop-shadow(0 2px 0 rgba(0,0,0,.35)); }
  .pad.fire{ flex:0.9; position:relative; }

  /* FIRE pad content */
  .fireInner{ display:flex; align-items:center; gap:8px; }
  .fireLabel{ font-weight:800; letter-spacing:0.3px; }
  .ammoBadge{
    min-width:2.1em; text-align:center; font-variant-numeric:tabular-nums;
    padding:4px 8px; border-radius:999px; background:rgba(88,166,255,.18);
    border:1px solid rgba(88,166,255,.35);
  }
  /* Lives (hearts) next to Shrink */
#lifeBar{
  pointer-events:none;
  display:flex;
  align-items:center;
  gap:6px;
  margin-left:10px;
}
#lifeBar .heart{
  font-size:22px;
  line-height:1;
  filter:drop-shadow(0 1px 0 rgba(0,0,0,.35));
}
#lifeBar .heart.empty{
  opacity:.35; /* “empty” look */
}

  #abilities{ position:absolute; left:0; right:0; bottom:110px; display:flex; justify-content:center; z-index:6; pointer-events:none; }
  #shrinkBtn{ pointer-events:auto; display:flex; align-items:center; gap:8px; }
  #shrinkCount{ min-width:1.6em; text-align:center; }

  /* Start overlay (raised above everything and clickable) */
  .overlay{
  position:absolute;
  inset:0;
  z-index:9999;
  display:flex;
  align-items:center;
  justify-content:center;
  pointer-events:auto;

  /* Blur & dim */
  background:rgba(0,0,0,.35);
  -webkit-backdrop-filter: blur(8px) saturate(1.05);
  backdrop-filter: blur(8px) saturate(1.05);

  text-align:center;
  padding:24px;
}

.overlay .card{
  background:transparent;
  border:none;
  border-radius:0;
  padding:0;
  backdrop-filter:none;
  pointer-events:auto;
}
  /* extra safety so button receives events */

  .card{ max-width:560px; width:92%; background:rgba(255,255,255,.08); border:1px solid rgba(255,255,255,.14); border-radius:18px; padding:18px; backdrop-filter:blur(10px); }
  .title{ font-size:26px; font-weight:800; margin:4px 0 10px; }
  .subtitle{ color:var(--muted); margin-bottom:14px; }
  .go{ margin-top:12px; width:100%; padding:12px 14px; font-weight:800; font-size:18px; border-radius:14px; border:none; color:#0b1220; background:var(--accent); }
  .muted{ color:var(--muted); font-size:13px; }
  .modal{ position:absolute; inset:0; z-index:12000; display:none; align-items:center; justify-content:center; background:rgba(0,0,0,.55); padding:18px; pointer-events:auto;}
  .panel{ width:min(520px,92%); background:#121826; border:1px solid rgba(255,255,255,.12); border-radius:16px; padding:16px; position:relative; }
  
  /* Always show a vertical scrollbar inside these modals */
#howtoModal .panel,
#lbModal .panel,
#storeModal .panel{
  overflow-y: scroll;      /* always shows the bar */
  overflow-x: hidden;
  max-height: min(82vh, 520px);  /* keeps panel usable on short screens */
  scrollbar-gutter: stable;      /* reserves space so layout doesn't jump */
}

/* Optional: tidy WebKit scrollbars (Chrome/Safari) */
#howtoModal .panel::-webkit-scrollbar,
#lbModal .panel::-webkit-scrollbar,
#storeModal .panel::-webkit-scrollbar{ width: 10px; }

#howtoModal .panel::-webkit-scrollbar-track,
#lbModal .panel::-webkit-scrollbar-track,
#storeModal .panel::-webkit-scrollbar-track{ background: rgba(255,255,255,.06); border-radius: 8px; }

#howtoModal .panel::-webkit-scrollbar-thumb,
#lbModal .panel::-webkit-scrollbar-thumb,
#storeModal .panel::-webkit-scrollbar-thumb{
  background: rgba(255,255,255,.22);
  border-radius: 8px;
  border: 2px solid rgba(0,0,0,0); /* gives a bit of padding/rounding */
}
  
  .panel h2{ margin:4px 0 12px; font-size:20px; }
  .grid{ display:grid; gap:10px; }
  .grid input{ width:100%; padding:10px; border-radius:10px; border:1px solid rgba(255,255,255,.15); background:#0f141f; color:var(--fg); }
  .actions{ display:flex; gap:10px; margin-top:8px; flex-wrap:wrap; }
  .btn2{ flex:1; padding:10px 12px; border-radius:12px; border:1px solid rgba(255,255,255,.18); background:rgba(255,255,255,.06); color:var(--fg); font-weight:700; }
  .btn2.primary{ background:var(--accent); color:#0b1220; border-color:transparent; }
  .x{ position:absolute; top:10px; right:12px; background:transparent; border:none; color:var(--muted); font-size:22px; }
  .small { font-size:12px; color:var(--muted); text-decoration:underline; background:none; border:none; padding:0; }

  /* ⬇️ Leaderboard table layout/spacing */
  #lbTable{ width:100%; border-collapse:separate; border-spacing:0; }
  #lbTable th,#lbTable td{ padding:8px 10px; }
  #lbTable td:nth-child(1){ width:32px; color:var(--muted); }
  #lbTable td:nth-child(3){ width:90px; text-align:right; }
  #lbTable td:nth-child(4){ width:96px; color:var(--muted); }
  /* Store item layout + coin size */
.itemBtn{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:12px;
  text-align:left;
}
.itemBtn .emoji{ font-size:18px; margin-right:6px; }
.itemBtn .label{ flex:1; display:flex; align-items:center; gap:8px; }
.itemBtn .cost{ display:flex; align-items:center; gap:6px; font-weight:800; }
.itemBtn .coinMini{ width:16px; height:16px; flex:0 0 auto; }
/* Small inline coins everywhere (how-to, lists, text) */
.coinMini{
  width:18px;            /* pick 14–20px to taste */
  height:18px;
  vertical-align:-2px;   /* lines up nicely with text */
  display:inline-block;  /* prevents odd line breaks in some browsers */
  flex:0 0 auto;
}
/* How-to modal tweaks */
/* How-to modal: always show vertical scrollbar */
#howtoModal .panel{
  display:flex;                 /* keep header fixed, content scrolls */
  flex-direction:column;
  max-height:min(86vh, 640px);  /* fit on small screens */
}

#howtoModal .panel .grid{
  flex:1 1 auto;
  overflow-y: scroll;           /* always show scrollbar (even if short) */
  scrollbar-gutter: stable;     /* reserve space so layout doesn’t shift */
  -webkit-overflow-scrolling: touch;
  padding-right:6px;            /* avoid clipping under the scrollbar */
  max-height:none;
}

/* Optional: theme the scrollbar to match your UI */
#howtoModal .panel .grid{
  scrollbar-width: thin;                                  /* Firefox */
  scrollbar-color: rgba(255,255,255,.18) rgba(255,255,255,.06);
}
#howtoModal .panel .grid::-webkit-scrollbar{ width:10px; }          /* WebKit */
#howtoModal .panel .grid::-webkit-scrollbar-thumb{
  background: rgba(255,255,255,.18);
  border-radius:8px;
  border:1px solid rgba(255,255,255,.12);
}
#howtoModal .panel .grid::-webkit-scrollbar-track{
  background: rgba(255,255,255,.06);
  border-radius:8px;
}
.howtoList { margin:8px 0 0; padding-left:18px; }
.howtoList li { margin:6px 0; }
/* Right cluster can scroll a bit if tight */
header .toolbar .right{
  flex-wrap:nowrap;
  overflow-x:auto;
  -webkit-overflow-scrolling:touch;
  scrollbar-width:none;
}
header .toolbar .right::-webkit-scrollbar{ display:none; }

/* Hide on toolbar, but still available in dropdown */
.hideOnToolbar{ display:none; }

/* Menu popup */
#menuPopup{
  position:absolute; z-index:12010; display:none;
  background:rgba(18,24,38,.98);
  border:1px solid rgba(255,255,255,.14);
  border-radius:12px; padding:8px; min-width:170px;
  box-shadow:0 10px 24px rgba(0,0,0,.35);
}
#menuPopup .menuItem{
  width:100%; text-align:left; margin:0; padding:10px 12px;
  border-radius:10px; border:1px solid rgba(255,255,255,.12);
  background:rgba(255,255,255,.04); color:var(--fg); font-weight:700;
}
#menuPopup .menuItem + .menuItem{ margin-top:8px; }

#gameOverText small {
  display: block;
  margin-top: 5px;
  font-size: 0.8em;
  color: #ccc;
}
/* When paused, let the HUD sit above the overlay so chips are tappable */
.paused-ui header{ z-index:12060; }
.paused-ui #menuPopup{ z-index:12060; } /* keep popup above everything */

/* Keep HUD & menu above ANY overlay (waiting / paused / game over) */
.overlay-ui header{ z-index:12060; }
.overlay-ui #menuPopup{ z-index:12070; } /* popup above the header */

/* Game wrapper: contains the canvas + controls + overlay */
#stage{
  position: relative;
  width: 100%;
  height: 100%;
  overflow: hidden; /* keep overlay/canvas neatly clipped */
}

/* All overlays INSIDE the stage blur only the game */
#stage .overlay{
  position: absolute;
  inset: 0;
  z-index: 9999;
  display: flex;
  align-items: center;
  justify-content: center;
  pointer-events: auto;

  /* nice dim + blur the game behind */
  background: rgba(0,0,0,.35);
  -webkit-backdrop-filter: blur(8px) saturate(1.05);
  backdrop-filter: blur(8px) saturate(1.05);

  text-align: center;
  padding: 24px;
}

/* Keep the card itself crisp & clickable */
#stage .overlay .card{
  pointer-events: auto;
}
/* Game wrapper: contains the canvas + controls + overlay */
#stage{
  position: relative;
  width: 100%;
  height: 100%;
  overflow: hidden; /* keep overlay/canvas neatly clipped */
}

/* All overlays INSIDE the stage blur only the game */
#stage .overlay{
  position: absolute;
  inset: 0;
  z-index: 9999;
  display: flex;
  align-items: center;
  justify-content: center;
  pointer-events: auto;

  /* dim + blur so colors still show through */
  background: rgba(0,0,0,.35);
  -webkit-backdrop-filter: blur(8px) saturate(1.05);
  backdrop-filter: blur(8px) saturate(1.05);

  text-align: center;
  padding: 24px;
}

/* Keep the card itself crisp & clickable */
#stage .overlay .card{
  pointer-events: auto;
}

/* Overlay typography */
.overlay .title{
  font-size:32px;
  font-weight:800;
  color:#fff;
  letter-spacing:.2px;
  text-shadow:0 1px 0 rgba(0,0,0,.35);
  margin:0 0 8px;
}
.overlay .subtitle{
  color:rgba(233,239,255,.88);
  font-size:15px;
  margin:0;
}
</style>
</head>
<body class="safe">
  <!-- Hidden SVG sprite: tiny D coin we can <use> anywhere -->
<svg aria-hidden="true" width="0" height="0" style="position:absolute;left:-9999px;visibility:hidden">
  <defs>
    <radialGradient id="cgStore" cx="40%" cy="35%" r="65%">
      <stop offset="0%"   stop-color="#ffe38a"/>
      <stop offset="55%"  stop-color="#f5c240"/>
      <stop offset="100%" stop-color="#c68a12"/>
    </radialGradient>

    <symbol id="dcoin" viewBox="0 0 64 64">
      <circle cx="32" cy="32" r="22" fill="url(#cgStore)"/>
      <circle cx="32" cy="32" r="22" fill="none" stroke="#000" stroke-opacity=".25" stroke-width="2"/>
      <g fill="#000" fill-opacity=".28">
        <circle cx="32" cy="10" r="2"/><circle cx="45" cy="14" r="2"/><circle cx="52" cy="26" r="2"/>
        <circle cx="52" cy="38" r="2"/><circle cx="45" cy="50" r="2"/><circle cx="32" cy="54" r="2"/>
        <circle cx="19" cy="50" r="2"/><circle cx="12" cy="38" r="2"/><circle cx="12" cy="26" r="2"/><circle cx="19" cy="14" r="2"/>
      </g>
      <circle cx="32" cy="32" r="13" fill="#000" fill-opacity=".15"/>
      <text x="32" y="38" text-anchor="middle" font-size="18" font-weight="800" fill="#2b1900">D</text>
    </symbol>
  </defs>
</svg>
<div id="stage">
<canvas id="game" aria-label="Dodger game area"></canvas>



<!-- Ability bar -->
<div id="abilities">
  <button id="shrinkBtn" class="btn">✂ Shrink <span id="shrinkCount" class="ammo">0</span></button>
  <div id="lifeBar" aria-label="Lives"></div>
</div>

<!-- Controls -->
<div class="controls">
  <div class="pad" id="leftPad"><span>⟵</span></div>
  <div class="pad fire" id="firePad" aria-label="Fire">
    <div class="fireInner">
      <span class="fireLabel">FIRE</span>
      <span id="ammo" class="ammoBadge">0</span>
    </div>
  </div>
  <div class="pad" id="rightPad"><span>⟶</span></div>
</div>

<!-- Start overlay -->
<div class="overlay" id="overlay">
  <div class="card">
    <div class="title">DODGER</div>
    <div class="subtitle" id="startSub">Avoid blocks. Power-ups: 🔫 Blaster, ✂ Shrink, 🛡 Shield, 🐌 Slow, 🧲 Magnet, ❤️ Life.</div>
    <button class="go" id="startBtn">Start</button>
    <div class="muted">Tip: Add to Home Screen on iPhone for full-screen play.</div>
  </div>
</div>
</div>

<header class="safe" id="hud">
  <div class="topbar">
    <div class="left">
      <div class="hud"><strong>Score:</strong><span id="score">0</span></div>
      <div class="hud"><strong>Best:</strong><span id="best">0</span></div>
      
    </div>
    <div class="right">
      <div id="userChip">Not signed in</div>
    </div>
  </div>

  <div class="toolbar">
    <div class="left">
  <div id="coinChip" title="Coins">
  <svg viewBox="0 0 64 64" aria-hidden="true">
    <defs>
      <radialGradient id="cg" cx="40%" cy="35%" r="65%">
        <stop offset="0%"   stop-color="#ffe38a"/>
        <stop offset="55%"  stop-color="#f5c240"/>
        <stop offset="100%" stop-color="#c68a12"/>
      </radialGradient>
    </defs>

    <circle cx="32" cy="32" r="22" fill="url(#cg)"/>
    <circle cx="32" cy="32" r="22" fill="none" stroke="#000" stroke-opacity=".25" stroke-width="2"/>

    <g fill="#000" fill-opacity=".28">
      <circle cx="32" cy="10" r="2"/>
      <circle cx="45" cy="14" r="2"/>
      <circle cx="52" cy="26" r="2"/>
      <circle cx="52" cy="38" r="2"/>
      <circle cx="45" cy="50" r="2"/>
      <circle cx="32" cy="54" r="2"/>
      <circle cx="19" cy="50" r="2"/>
      <circle cx="12" cy="38" r="2"/>
      <circle cx="12" cy="26" r="2"/>
      <circle cx="19" cy="14" r="2"/>
    </g>

    <circle cx="32" cy="32" r="13" fill="#000" fill-opacity=".15"/>
    <text x="32" y="38" text-anchor="middle" font-size="18" font-weight="800" fill="#2b1900">D</text>
  </svg>
  <span id="coinCount">0</span>
</div>

  <!-- Store chip -->
  <button id="storeBtn" class="btn" title="Open store">Store</button>
</div>
    <div class="right">
  <button class="btn" id="lbBtn">Leaderboard</button>
  <button class="btn" id="howtoBtn">How to play</button>

  <!-- ▼ New gear Menu button -->
  <button class="btn" id="menuBtn" title="Menu">
    <svg aria-hidden="true" width="14" height="14" viewBox="0 0 24 24">
      <path fill="currentColor"
        d="M12 8.75a3.25 3.25 0 1 0 0 6.5a3.25 3.25 0 0 0 0-6.5Zm9 3.25l-1.86.78c-.13.41-.3.8-.5 1.17l.99 1.74-1.41 1.41-1.74-.99c-.37.2-.76.37-1.17.5L14.5 21h-2.99l-.78-1.86a7.1 7.1 0 0 1-1.17-.5l-1.74.99-1.41-1.41.99-1.74a7.1 7.1 0 0 1-.5-1.17L3 12V9.01l1.86-.78c.13-.41.3-.8.5-1.17L4.37 5.32 5.78 3.9l1.74.99c.37-.2.76-.37 1.17-.5L11.51 2h2.99l.78 1.86c.41.13.8.3 1.17.5l1.74-.99 1.41 1.41-.99 1.74c.2.37.37.76.5 1.17L21 9.01V12Z"/>
    </svg>
    Menu
  </button>
  <!-- ▲ New gear Menu button -->

  <!-- Keep these in DOM but hide them on the toolbar (CSS will hide .hideOnToolbar) -->
  <button class="btn hideOnToolbar" id="nameBtn">Set name</button>
  <button class="btn hideOnToolbar" id="authBtn">Account</button>

  <button class="btn" id="pauseBtn" aria-label="Pause or resume">Pause</button>
</div>
<!-- Dropdown that opens under the Menu button -->
<div id="menuPopup" role="menu" aria-label="Menu">
  <button class="menuItem" id="menuNameBtn">Set name</button>
  <button class="menuItem" id="menuAccountBtn">Account</button>
</div>
  </div>
</header>

<!-- Name modal -->
<div class="modal" id="nameModal">
  <div class="panel">
    <button class="x" id="nameClose">×</button>
    <h2>Set display name</h2>
    <div class="grid"><input id="displayName" type="text" maxlength="24" placeholder="e.g., JohnH"></div>
    <div class="actions">
      <button class="btn2" id="cancelName">Cancel</button>
      <button class="btn2 primary" id="saveName">Save</button>
    </div>
    <div class="muted">Used on the global leaderboard.</div>
  </div>
</div>

<!-- Leaderboard modal -->
<div class="modal" id="lbModal">
  <div class="panel">
    <button class="x" id="lbClose">×</button>
    <h2>Global Leaderboard (Top 100)</h2>
    <table id="lbTable">
      <thead><tr><th style="text-align:left;">#</th><th style="text-align:left;">Name</th><th>Score</th><th>When</th></tr></thead>
      <tbody></tbody>
    </table>
    <div class="muted">Finish a run to submit your score.</div>
  </div>
</div>

<!-- How to play modal -->
<div class="modal" id="howtoModal">
  <div class="panel">
    <button class="x" id="howtoClose">×</button>
    <h2>How to play</h2>

    <div class="grid" style="gap:14px;">
      <div>
        <strong>Move left/right</strong>
        <ul class="howtoList">
          <li><strong>Tap</strong> the left ⟵ or right ⟶ pads.</li>
          <li><strong>Swipe/slide</strong> on the game area to drift your square.</li>
        </ul>
      </div>

      <div>
        <strong>Fire blaster</strong>
        <ul class="howtoList">
          <li>Press <strong>FIRE</strong> (or spacebar) when you have ammo 🔫.</li>
          <li>Bullets destroy red blocks and add points.</li>
        </ul>
      </div>

      <div>
        <strong>Power-ups</strong>
        <ul class="howtoList">
          <li>🔫 <em>Blaster</em>: +6 ammo.</li>
          <li>✂️ <em>Shrink</em>: temporarily smaller and harder to hit. Tap <strong>✂ Shrink</strong> to use.</li>
          <li>🛡 <em>Shield</em>: one hit protection for a short time.</li>
          <li>🐌 <em>Slow</em>: slows falling blocks briefly.</li>
          <li>🧲 <em>Magnet</em>: pulls power-ups toward you.</li>
          <li>❤️ <em>Life</em>: +1 extra life (max 5).</li>
        </ul>
      </div>

      <div>
        <strong>Coins & Store</strong>
        <ul class="howtoList">
          <li>Collect <svg class="coinMini" style="vertical-align:-2px;"><use href="#dcoin"></use></svg> coins while you play.</li>
          <li>Open <strong>Store</strong> to buy:
            <ul class="howtoList">
              <li>🔫 Ammo (+6) — <span class="num">5</span> <svg class="coinMini"><use href="#dcoin"></use></svg></li>
              <li>✂️ Shrink charge (+1) — <span class="num">8</span> <svg class="coinMini"><use href="#dcoin"></use></svg></li>
              <li>❤️ Life (+1) — <span class="num">10</span> <svg class="coinMini"><use href="#dcoin"></use></svg></li>
            </ul>
          </li>
          <li>Purchases apply to the current run.</li>
        </ul>
      </div>
    </div>
  </div>
</div>

<!-- Account modal -->
<div class="modal" id="authModal">
  <div class="panel">
    <button class="x" id="authClose">×</button>
    <h2>Account</h2>
    <div id="authMsg" class="muted" style="margin-bottom:8px;"></div>
    <div class="grid">
      <input id="authEmail" type="email" placeholder="Email"
             autocapitalize="none" autocomplete="username"
             inputmode="email" spellcheck="false">
      <input id="authPass" type="password" placeholder="Password (min 6)"
             autocomplete="current-password">
    </div>
    <div class="actions">
      <button class="btn2" id="authSignin">Sign in</button>
      <button class="btn2 primary" id="authSignup">Create account</button>
      <button class="btn2" id="authSignout">Sign out</button>
    </div>
    <div style="margin-top:6px; display:flex; justify-content:flex-end;">
      <button class="small" id="authForgot">Forgot password?</button>
    </div>
  </div>
</div>

<!-- Store modal -->
<div class="modal" id="storeModal">
  <div class="panel">
    <button class="x" id="storeClose">×</button>
    <h2>Store</h2>

    <div id="storeMsg" class="muted" style="margin-bottom:8px;"></div>

  <div class="grid">
  <button class="btn2 itemBtn" id="buyAmmo" title="Buy blaster ammo">
    <span class="emoji">🔫</span>
    <span class="label"><strong>Buy Blaster</strong> ammo (+6)</span>
    <span class="cost"><span class="num">5</span><svg class="coinMini"><use href="#dcoin"></use></svg></span>
  </button>

  <button class="btn2 itemBtn" id="buyShrink" title="Buy a shrink charge">
    <span class="emoji">✂️</span>
    <span class="label"><strong>Buy Shrink</strong> charge (+1)</span>
    <span class="cost"><span class="num">8</span><svg class="coinMini"><use href="#dcoin"></use></svg></span>
  </button>

  <button class="btn2 itemBtn" id="buyLife" title="Buy one life">
    <span class="emoji">❤️</span>
    <span class="label"><strong>Buy Life</strong> (+1)</span>
    <span class="cost"><span class="num">10</span><svg class="coinMini"><use href="#dcoin"></use></svg></span>
  </button>
</div>

    <div class="muted" style="margin-top:10px;">
      Purchases apply to the current run. (Persistent lives coming soon.)
    </div>
  </div>
</div>

<!-- ===== Firebase (Auth + Firestore) ===== -->
<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-app.js";
  import {
    getAuth, onAuthStateChanged,
    signInWithEmailAndPassword, createUserWithEmailAndPassword,
    updateProfile, signOut,
    browserLocalPersistence, setPersistence,
    sendPasswordResetEmail
  } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-auth.js";
  import {
    getFirestore, collection, addDoc, query, orderBy, limit, getDocs, serverTimestamp,
    doc, setDoc, getDoc, updateDoc, increment, onSnapshot
  } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-firestore.js";

  const firebaseConfig = {
    apiKey: "AIzaSyD37Lc_tHwEkmXSHwDr6QUTNeWXGOKAftg",
    authDomain: "dodger-4aad1.firebaseapp.com",
    projectId: "dodger-4aad1",
    storageBucket: "dodger-4aad1.appspot.com",
    messagingSenderId: "148070811748",
    appId: "1:148070811748:web:1ed51b4872b9d9106b3771",
    measurementId: "G-NV3R6CEYH7"
  };

  const app = initializeApp(firebaseConfig);
  const auth = getAuth(app);
  const db   = getFirestore(app);

  setPersistence(auth, browserLocalPersistence).catch(()=>{});

  // ── Helpers exposed to game code (aligned to your rules)
  let walletUnsub = null;

  window.firebase = {
    auth, db,

    onUser(cb){ return onAuthStateChanged(auth, cb); },

    async ensureWallet(uid){
      const ref = doc(db, "wallets", uid);
      const s = await getDoc(ref).catch(()=>null);
      if (!s || !s.exists()) await setDoc(ref, { coins: 0 });
      return ref;
    },

    async watchWallet(uid, onCoins){
      if (walletUnsub) { walletUnsub(); walletUnsub = null; }
      if (!uid) { onCoins?.(0); return; }
      const ref = await this.ensureWallet(uid);
      walletUnsub = onSnapshot(ref, (snap)=>{
        const coins = Number(snap.data()?.coins || 0);
        onCoins?.(coins);
      });
    },

    async setDisplayName(name){
      if (!auth.currentUser) return;
      const clean = String(name||"Player").trim().slice(0,24);
      await updateProfile(auth.currentUser, { displayName: clean });
      return clean;
    },

    async saveScore(score){
      if (!auth.currentUser) return { ok:false, error:"Not signed in" };
      try{
        await addDoc(collection(db,"scores"),{
          uid: auth.currentUser.uid,
          name: auth.currentUser.displayName || auth.currentUser.email || "Player",
          score: Math.floor(Number(score)||0),
          ts: serverTimestamp()
        });
        return { ok:true };
      }catch(e){ return { ok:false, error:e.message }; }
    },

    async addCoins(n){
      const u = auth.currentUser;
      if (!u) throw new Error("Not signed in");
      const ref = await this.ensureWallet(u.uid);
      await updateDoc(ref, { coins: increment(n|0) });
    },

    async loadTop(n = 20){
      try{
        const q1 = query(
          collection(db,"scores"),
          orderBy("score","desc"),
          orderBy("ts","desc"),
          limit(n)
        );
        const s1 = await getDocs(q1);
        return s1.docs.map(d => {
          const data = d.data() || {};
          return { name: data.name||"Player", score: Number(data.score)||0, ts: data.ts||null };
        });
      }catch(e){
        // Fallback if the composite index isn't available
        const q2 = query(collection(db,"scores"), orderBy("score","desc"), limit(n));
        const s2 = await getDocs(q2);
        return s2.docs.map(d => {
          const data = d.data() || {};
          return { name: data.name||"Player", score: Number(data.score)||0, ts: data.ts||null };
        });
      }
    }
  };

  function prettyAuthError(err){
    const code = (err && err.code) || "";
    if (code.includes("invalid-credential")) return "Email or password is incorrect.";
    if (code.includes("user-disabled")) return "This account is disabled.";
    if (code.includes("too-many-requests")) return "Too many attempts. Try again later.";
    if (code.includes("email-already-in-use")) return "Account exists. Use Sign in.";
    if (code.includes("invalid-email")) return "That email address looks invalid.";
    if (code.includes("weak-password")) return "Password must be at least 6 characters.";
    return (err && err.message) || "Authentication error.";
  }

  // ── Auth UI wiring + wallet sync
  const userChip = document.getElementById("userChip");
  const coinCountEl = document.getElementById("coinCount");
  const authBtn = document.getElementById("authBtn");
  const authModal = document.getElementById("authModal");
  const authClose = document.getElementById("authClose");
  const authEmail = document.getElementById("authEmail");
  const authPass = document.getElementById("authPass");
  const authMsg  = document.getElementById("authMsg");
  const btnIn    = document.getElementById("authSignin");
  const btnUp    = document.getElementById("authSignup");
  const btnOut   = document.getElementById("authSignout");
  const btnForgot= document.getElementById("authForgot");
  const startBtn = document.getElementById("startBtn");
  const startSub = document.getElementById("startSub");

  onAuthStateChanged(auth, async (u)=>{
  if (!u){
    userChip.textContent = "Not signed in";
    coinCountEl.textContent = "0";
    await window.firebase.watchWallet(null, null);
    // Keep the simple, non-emoji message
    startSub.textContent = "Two-finger tap to pause. Tap to start.";
    startBtn.textContent = "Sign in";
    return;
  }

  userChip.textContent = u.displayName ? `Signed in: ${u.displayName}` :
                         u.email ? `Signed in: ${u.email}` : "Signed in";
  await window.firebase.watchWallet(u.uid, (coins)=>{ coinCountEl.textContent = String(coins); });

  // Keep the same non-emoji message even when signed in
  startSub.textContent = "Two-finger tap to pause. Tap to start.";
  startBtn.textContent = "Start";
});

  function openModal(m){
  m.style.display = "flex";
  document.body.classList.add("ui-lock");
}
function closeModal(m){
  m.style.display = "none";
  document.body.classList.remove("ui-lock");
  window.blockResume?.();              // brief shield so the close tap can't resume
}

  document.querySelectorAll(".modal").forEach(m=>{
    m.addEventListener("pointerdown", (e)=>{ if(e.target === m) closeModal(m); }, {passive:true});
  });
  document.addEventListener("keydown", (e)=>{
    if (e.key === "Escape") document.querySelectorAll(".modal").forEach(m=>{ if(m.style.display==="flex") closeModal(m); });
  });

  authBtn.addEventListener("pointerdown", e=>{ e.preventDefault(); openModal(authModal); });
  authClose.addEventListener("pointerdown", e=>{ e.preventDefault(); closeModal(authModal); });

  // Sign in / Sign up
  btnIn.addEventListener("pointerdown", async e=>{
    e.preventDefault(); authMsg.textContent = "";
    try{
      const email = (authEmail.value || "").trim();
      const pass  = authPass.value || "";
      await signInWithEmailAndPassword(auth, email, pass);
      closeModal(authModal);
    }catch(err){ authMsg.textContent = prettyAuthError(err); }
  });
  btnUp.addEventListener("pointerdown", async e=>{
    e.preventDefault(); authMsg.textContent = "";
    try{
      const email = (authEmail.value || "").trim();
      const pass  = authPass.value || "";
      const cred = await createUserWithEmailAndPassword(auth, email, pass);
      const def = email.split("@")[0].slice(0,24) || "Player";
      await updateProfile(cred.user, { displayName: def });
      closeModal(authModal);
    }catch(err){ authMsg.textContent = prettyAuthError(err); }
  });
  btnOut.addEventListener("pointerdown", async e=>{
    e.preventDefault(); await signOut(auth); closeModal(authModal);
  });

  // Password reset
  btnForgot.addEventListener("pointerdown", async e=>{
    e.preventDefault();
    const email = (authEmail.value || "").trim();
    if (!email) { authMsg.textContent = "Enter your email first, then tap Reset."; return; }
    try{
      await sendPasswordResetEmail(auth, email);
      authMsg.textContent = "Password reset email sent. Check your inbox.";
    }catch(err){
      authMsg.textContent = prettyAuthError(err);
    }
  });
</script>

<!-- ===== Game code ===== -->
<script>
(function () {
  "use strict";
  // --- Spawn tuning (independent) ---
let COIN_CHANCE = 0.55;            // 0..1 chance when coin timer fires
let COIN_INTERVAL_MIN = 6, COIN_INTERVAL_MAX = 10;      // seconds

let POWERUP_INTERVAL_MIN = 8, POWERUP_INTERVAL_MAX = 13; // seconds

  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d", { alpha:false, desynchronized:true });

  // Reserve vertical space for bottom UI so the player can't sit under it
  let uiBottom = 140;
  function measureUIBottom(){
    const controls  = document.querySelector('.controls');
    const abilities = document.getElementById('abilities');
    let occ = 0;
    if (controls){
      const r = controls.getBoundingClientRect();
      occ = Math.max(occ, Math.ceil(r.height || 0));
    }
    if (abilities){
      const r = abilities.getBoundingClientRect();
      const fromBottom = Math.max(0, Math.ceil(window.innerHeight - r.top));
      occ = Math.max(occ, fromBottom);
    }
    uiBottom = Math.max(occ + 16, 120);
  }

  let width=0, height=0, dpr=Math.max(1, window.devicePixelRatio||1);
  function fit(){
    width=Math.max(320,Math.floor(window.innerWidth||document.documentElement.clientWidth));
    height=Math.max(480,Math.floor(window.innerHeight||document.documentElement.clientHeight));
    dpr=Math.max(1, window.devicePixelRatio||1);
    canvas.width=Math.floor(width*dpr); canvas.height=Math.floor(height*dpr);
    canvas.style.width=width+"px"; canvas.style.height=height+"px";
    ctx.setTransform(dpr,0,0,dpr,0,0);
    measureUIBottom();
  }
  fit(); window.addEventListener("resize", fit);

  // UI refs
  const scoreEl = document.getElementById("score");
  const bestEl  = document.getElementById("best");
  const ammoEl  = document.getElementById("ammo");
  const livesEl = document.getElementById("lives");
  const coinCountEl = document.getElementById("coinCount");
  const startBtn= document.getElementById("startBtn");
  const pauseBtn= document.getElementById("pauseBtn");
  const overlay = document.getElementById("overlay");
  const leftPad = document.getElementById("leftPad");
  const rightPad= document.getElementById("rightPad");
  const firePad = document.getElementById("firePad");
  const nameBtn = document.getElementById("nameBtn");
  const nameModal = document.getElementById("nameModal");
  const nameClose = document.getElementById("nameClose");
  const cancelName= document.getElementById("cancelName");
  const saveName  = document.getElementById("saveName");
  const nameInput = document.getElementById("displayName");
  const lbBtn = document.getElementById("lbBtn");
  const lbModal = document.getElementById("lbModal");
  const lbClose = document.getElementById("lbClose");
  const lbBody = document.querySelector("#lbTable tbody");
  const shrinkBtn = document.getElementById("shrinkBtn");
  const shrinkCountEl = document.getElementById("shrinkCount");
  // MENU (gear)
const menuBtn        = document.getElementById("menuBtn");
const menuPopup      = document.getElementById("menuPopup");
const menuNameBtn    = document.getElementById("menuNameBtn");
const menuAccountBtn = document.getElementById("menuAccountBtn");
  // Store UI
const storeBtn   = document.getElementById("storeBtn");
const storeModal = document.getElementById("storeModal");
const storeClose = document.getElementById("storeClose");
const storeMsg   = document.getElementById("storeMsg");
// ── Start/Pause overlay helpers ──────────────────────────────────────────
const overlayCard  = document.querySelector("#overlay .card");
const overlayTitle = document.querySelector("#overlay .title");
let showingPaused  = false;
// Prevents accidental resume for ~250ms after closing any UI
let _resumeBlockUntil = 0;
window.blockResume = function(ms = 250){
  _resumeBlockUntil = performance.now() + ms;
};

function ensureSubtitle(){
  let sub = document.querySelector("#overlay .subtitle");
  if (!sub) {
    sub = document.createElement("div");
    sub.className = "subtitle";
    overlayCard.appendChild(sub);
  }
  return sub;
}

function showWaitingOverlay(){
  showingPaused = false;
  overlay.style.display = "flex";
  overlayTitle.textContent = "DODGER";
  ensureSubtitle().textContent = "Two-finger tap to pause. Tap to start.";
  document.body.classList.add ('overlay-ui');
}

function showPausedOverlay(){
  showingPaused = true;
  overlay.style.display = "flex";
  overlayTitle.textContent = "Paused";
  ensureSubtitle().textContent = "Tap to resume";
  document.body.classList.add ('overlay-ui');
}

// Start with the waiting screen visible
showWaitingOverlay();

// Tap anywhere on the overlay: start or resume
// Tap anywhere on the overlay: start or resume
function tryStartOrResume(e){
  e.preventDefault();

  // 1) Don’t resume if any UI is open or we’re inside the HUD/menu
  if (document.body.classList.contains("ui-lock")) return;
  if (e.target.closest("header, #menuPopup")) return;

  // 2) Don’t resume immediately after a UI closes (shield)
  if (performance.now() < _resumeBlockUntil) return;

  // 3) If we were paused, resume
  if (showingPaused && !state.over) {
    overlay.style.display = "none";
    showingPaused = false;
    if (state.paused) togglePause();  // unpause + restart loop
    return;
  }

  // 4) Otherwise start a fresh run (auth-gated)
  if (!window.firebase.auth.currentUser){
    openModal(document.getElementById("authModal"));
    return;
  }
  startGame();
}
overlay.addEventListener("pointerdown", tryStartOrResume);
overlay.addEventListener("click", tryStartOrResume);
const buyAmmo    = document.getElementById("buyAmmo");
const buyShrink  = document.getElementById("buyShrink");
const buyLife    = document.getElementById("buyLife");
const howtoBtn   = document.getElementById("howtoBtn");
const howtoModal = document.getElementById("howtoModal");
const howtoClose = document.getElementById("howtoClose");

howtoBtn.addEventListener("pointerdown", e => {
  e.preventDefault();
  howtoModal.style.display = "flex";
});

howtoClose.addEventListener("pointerdown", e => {
  e.preventDefault();
  closeModal(howtoModal);
});

// Open the store (require sign-in)
storeBtn.addEventListener("pointerdown", (e)=>{
  e.preventDefault();
  if (!window.firebase.auth.currentUser){
    // Force sign-in first
    document.getElementById("authModal").style.display = "flex";
    return;
  }
  storeMsg.textContent = ""; // clear old message
  storeMsg.style.color = "var(--muted)";
  storeModal.style.display = "flex";
});

// Close the store

storeClose.addEventListener("pointerdown", (e)=>{
  e.preventDefault();
  closeModal(storeModal);
});
function getCoins(){
  // coinCountEl is kept live by wallet listener in the Firebase script
  return (Number(coinCountEl.textContent || "0") | 0);
}

async function spendCoins(cost){
  if (!window.firebase.auth.currentUser) throw new Error("Sign in to buy.");
  const have = getCoins();
  if (have < cost) throw new Error(`You need ${cost} coins (you have ${have}).`);
  // Deduct via Firestore (server-side authoritative)
  await window.firebase.addCoins(-cost);
}

function flashStoreMsg(text, ok=true){
  storeMsg.textContent = text;
  storeMsg.style.color = ok ? "var(--fg)" : "var(--danger)";
}
buyAmmo.addEventListener("pointerdown", async (e)=>{
  e.preventDefault();
  try{
    await spendCoins(5);
    state.ammo += 6;
    ammoEl.textContent = state.ammo;
    flashStoreMsg("Purchased +6 ammo.");
  }catch(err){
    flashStoreMsg(err.message || String(err), false);
  }
});

buyShrink.addEventListener("pointerdown", async (e)=>{
  e.preventDefault();
  try{
    await spendCoins(8);
    state.shrinkCharges += 1;
    shrinkCountEl.textContent = state.shrinkCharges;
    flashStoreMsg("Purchased +1 shrink charge.");
  }catch(err){
    flashStoreMsg(err.message || String(err), false);
  }
});

buyLife.addEventListener("pointerdown", async (e)=>{
  e.preventDefault();
  try{
    await spendCoins(10);
    state.lives = Math.min(5, state.lives + 1);
    renderHearts();
    flashStoreMsg("Purchased +1 life.");
  }catch(err){
    flashStoreMsg(err.message || String(err), false);
  }
});
const lifeBar = document.getElementById("lifeBar");
function renderHearts(){
  if (!lifeBar) return;
  const max = 5;
  const out = [];
  for (let i = 0; i < max; i++){
    const filled = i < state.lives;
    out.push(`<span class="heart${filled ? "" : " empty"}">${filled ? "❤️" : "🤍"}</span>`);
  }
  lifeBar.innerHTML = out.join("");
}
  
  const prevent = (e) => { 
  if (
    e.target.closest(".overlay") ||
    e.target.closest(".modal")   ||
    e.target.closest("#menuPopup") // ✅ allow touches inside menu popup
  ) return;
  e.preventDefault();
};
["touchstart","touchmove","touchend","gesturestart"].forEach(ev => 
  document.addEventListener(ev, prevent, { passive:false })
);

  // Name modal
  nameBtn.addEventListener("pointerdown", e=>{ e.preventDefault(); nameModal.style.display="flex"; });

[nameClose,cancelName].forEach(el=>el.addEventListener("pointerdown", e=>{
  e.preventDefault();
  closeModal(nameModal);
}));
  saveName.addEventListener("pointerdown", async e=>{
    e.preventDefault();
    const dn = await window.firebase?.setDisplayName?.(nameInput.value||"Player");
    if (dn) { const uc=document.getElementById("userChip"); uc.textContent = `Signed in: ${dn}`; }
    nameModal.style.display="none";
  });

  // Leaderboard modal
  lbBtn.addEventListener("pointerdown", async e=>{
    e.preventDefault();
    lbBody.innerHTML = "<tr><td colspan='4'>Loading…</td></tr>";
    try{
      const rows = await window.firebase.loadTop(100);
      if (!rows.length) {
        lbBody.innerHTML = "<tr><td colspan='4'>No scores yet.</td></tr>";
      } else {
        let i=1;
        lbBody.innerHTML = rows.map(r=>{
          const whenDate = r.ts?.toDate ? r.ts.toDate() : null;
          const whenTxt = (whenDate instanceof Date && !isNaN(whenDate))
              ? whenDate.toLocaleDateString(undefined,{month:'short', day:'2-digit'})
              : "";
          return `<tr>
            <td>${i++}</td>
            <td>${escapeHtml(r.name||"Player")}</td>
            <td style="text-align:right">${(r.score|0)}</td>
            <td>${whenTxt}</td>
          </tr>`;
        }).join("");
      }
    }catch(err){
      lbBody.innerHTML = `<tr><td colspan="4">Error: ${escapeHtml(err.message||String(err))}</td></tr>`;
    }
    lbModal.style.display="flex";
  });
  lbClose.addEventListener("pointerdown", e=>{
  e.preventDefault();
  closeModal(lbModal);
});
  function escapeHtml(x){ return (x||"").replace(/[&<>"']/g, m=>({ "&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#39;" }[m])); }
  
  // ── Menu dropdown logic
function positionMenuPopup(){
  const r = menuBtn.getBoundingClientRect();
  menuPopup.style.left = Math.round(r.left) + "px";
  menuPopup.style.top  = Math.round(r.bottom + 6) + "px";
}
function openMenu(){
  positionMenuPopup();
  menuPopup.style.display = "block";
  menuBtn.setAttribute("aria-expanded", "true");
}
function closeMenu(){
  menuPopup.style.display = "none";
  menuBtn.setAttribute("aria-expanded", "false");
  window.blockResume?.();  // brief shield so that close tap doesn’t resume
}

menuBtn.addEventListener("pointerdown", (e)=>{
  e.preventDefault();
  const open = menuPopup.style.display === "block";
  if (open) closeMenu(); else openMenu();
});

// click outside to close
document.addEventListener("pointerdown", (e)=>{
  if (!menuPopup.contains(e.target) && e.target !== menuBtn){
    closeMenu();
  }
}, {passive:true});

// Esc closes
document.addEventListener("keydown", (e)=>{
  if (e.key === "Escape") closeMenu();
});

// Keep popup anchored on rotate/resize
window.addEventListener("resize", ()=>{
  if (menuPopup.style.display === "block") positionMenuPopup();
});

// Menu items forward to your existing modals
// One delegated handler for all items in the popup
menuPopup.addEventListener("pointerdown", (e)=>{
  const item = e.target.closest(".menuItem");
  if (!item) return;

  e.preventDefault();
  e.stopPropagation();           // don't let the outside-click listener fire
  closeMenu();

  if (item.id === "menuNameBtn") {
    document.getElementById("nameModal").style.display = "flex";
  } else if (item.id === "menuAccountBtn") {
    document.getElementById("authModal").style.display = "flex";
  }
});

  // Game state
  const state = {
    running:false, paused:false, over:false,
    score:0, best:Number(localStorage.getItem("dodger_best")||0),
    time:0, last:performance.now(),
    player:{ x:0, y:0, w:48, h:48, speed:420, vx:0, scale:1, invUntil:0 },
    blocks:[], blockTimer:0, difficulty:1,
    input:{ left:false, right:false, swipeVX:0 },
    bullets:[],
    ammo:0, lives:0, shrinkCharges:0,
    powerups:[], powTimer:2.5,
    coinTimer:3.5,
    effects:{ shrinkUntil:0, shieldUntil:0, slowUntil:0, magnetUntil:0 },
    coins:[]
    
  };
  bestEl.textContent = state.best;
ammoEl.textContent = state.ammo;
shrinkCountEl.textContent = state.shrinkCharges;
renderHearts();

  function resetPlayer(){
    const base = Math.max(36, Math.min(56, Math.floor(Math.min(width,height)*0.06)));
    state.player.w = base; state.player.h = base;
    state.player.vx = 0; state.player.scale = 1;

    const pw = state.player.w * state.player.scale;
    const ph = state.player.h * state.player.scale;
    const floorY = height - uiBottom - ph - 10; // keep above controls/abilities

    state.player.x = (width - pw)/2;
    state.player.y = Math.max(0, floorY);
  }
  resetPlayer();

  // Input
  function bindPad(el,dir){ const down=(e)=>{ e.preventDefault(); if(dir<0) state.input.left=true; else state.input.right=true; };
    const up=(e)=>{ if(dir<0) state.input.left=false; else state.input.right=false; };
    el.addEventListener("pointerdown", down); el.addEventListener("pointerup", up); el.addEventListener("pointercancel", up); el.addEventListener("pointerleave", up); }
  bindPad(leftPad,-1); bindPad(rightPad,1);

  let swipeActive=false, swipeStartX=0;
  canvas.addEventListener("pointerdown", e=>{ swipeActive=true; swipeStartX=e.clientX; });
  window.addEventListener("pointermove", e=>{ if(!swipeActive) return; const dx=e.clientX-swipeStartX; state.input.swipeVX=dx*3; });
  window.addEventListener("pointerup", ()=>{ swipeActive=false; state.input.swipeVX=0; });

  firePad.addEventListener("pointerdown", e=>{ e.preventDefault(); shoot(); });
  shrinkBtn.addEventListener("pointerdown", e=>{ e.preventDefault(); useShrink(); });

  window.addEventListener("keydown", e=>{
    if(e.key==="ArrowLeft"||e.key==="a") state.input.left=true;
    if(e.key==="ArrowRight"||e.key==="d") state.input.right=true;
    if(e.key===" ") { e.preventDefault(); shoot(); }
    if(e.key==="Shift") { e.preventDefault(); useShrink(); }
  });
  window.addEventListener("keyup", e=>{
    if(e.key==="ArrowLeft"||e.key==="a") state.input.left=false;
    if(e.key==="ArrowRight"||e.key==="d") state.input.right=false;
  });

  // Start button — support both click and pointerdown, and force sign-in when needed
  function handleStart(e){
    e.preventDefault();
    if (!window.firebase.auth.currentUser){
      document.getElementById("authModal").style.display = "flex";
      return;
    }
    startGame();
  }
  startBtn.addEventListener("pointerdown", handleStart);
  startBtn.addEventListener("click", handleStart);

  pauseBtn.addEventListener("pointerdown", e=>{ e.preventDefault(); togglePause(); });

  function startGame(){
    state.blocks.length=0; state.bullets.length=0; state.powerups.length=0; state.coins.length=0;
    state.score=0; state.time=0; state.blockTimer=0; state.powTimer=2.5; state.coinTimer =2.5;
    state.difficulty=1; state.over=false; state.paused=false;
    state.effects = { shrinkUntil:0, shieldUntil:0, slowUntil:0, magnetUntil:0 };
    state.player.invUntil = 0;
    state.ammo = 0;
state.shrinkCharges = 0;
state.lives = 0;
ammoEl.textContent = "0";
shrinkCountEl.textContent = "0";
renderHearts();
    resetPlayer();
    overlay.style.display="none";
    document.body.classList.remove('overlay-ui','paused-ui');
    state.running=true; state.last=performance.now();
    
    requestAnimationFrame(loop);
  }

async function gameOver(){
    state.over = true;
    state.running = false;

    overlay.style.display = "flex";
    document.body.classList.add('overlay-ui');
document.body.classList.remove('paused-ui');   // ensure we’re not in paused mode
    overlayTitle.textContent = "Game Over";
    const sub = ensureSubtitle();
    sub.innerHTML = `You scored <strong>${Math.floor(state.score)}</strong>. Tap to start.<br><small>Two finger tap to pause</small>`;

    state.best = Math.max(state.best, Math.floor(state.score));
    localStorage.setItem("dodger_best", String(state.best));
    bestEl.textContent = state.best;

    try { 
        await window.firebase.saveScore(state.score); 
    } catch(_){}
}

function togglePause(){
  if(!state.running || state.over) return;
  state.paused = !state.paused;
  pauseBtn.textContent = state.paused ? "Resume" : "Pause";

  if (state.paused){
    document.body.classList.add('paused-ui');   // << float HUD above overlay
    showPausedOverlay();                         // "Paused — Tap to resume"
  } else {
    document.body.classList.remove('paused-ui'); // << restore normal stacking
    overlay.style.display = "none";
    document.body.classList.remove('overlay-ui');  // overlay no longer visible
    showingPaused = false;
    state.last = performance.now();
    requestAnimationFrame(loop);
  }
}

  function rand(min,max){ return Math.random()*(max-min)+min; }
  function roundRect(ctx,x,y,w,h,r,fill){ ctx.beginPath(); const rr=Math.min(r,w/2,h/2);
    ctx.moveTo(x+rr,y); ctx.arcTo(x+w,y, x+w,y+h, rr); ctx.arcTo(x+w,y+h, x,y+h, rr);
    ctx.arcTo(x,y+h, x,y, rr); ctx.arcTo(x,y, x+w,y, rr); ctx.closePath(); if(fill) ctx.fill(); }

  function spawnBlock(){
    const size = rand(Math.max(22,width*0.03), Math.max(38,width*0.07));
    const x = rand(0, width - size);
    const speed = rand(140, 190) * state.difficulty;
    state.blocks.push({ x, y:-size, w:size, h:size, vy:speed });
  }
  function spawnPowerup(){
    const r = Math.random()*100;
    let type = "blaster";
    if (r<30) type="blaster";
    else if (r<50) type="shrink";
    else if (r<65) type="shield";
    else if (r<80) type="slow";
    else if (r<90) type="magnet";
    else type="life";
    const size = Math.max(26, Math.floor(Math.min(width,height)*0.05));
    const x = rand(0, width - size);
    const vy = rand(90, 130);
    state.powerups.push({ type, x, y:-size, w:size, h:size, vy });
  }
  function spawnCoin(){
    const size = Math.floor(Math.max(18, state.player.w * 0.70));
    const x = rand(0, width - size);
    const vy = rand(80, 120);
    const t0 = state.time;
    state.coins.push({ x, y:-size, w:size, h:size, vy, t0 });
  }

  function shoot(){
    if (state.ammo <= 0 || state.over || !state.running) return;
    state.ammo--; ammoEl.textContent = state.ammo;
    const p = state.player, cx = p.x + (p.w*p.scale)/2 - 4;
    state.bullets.push({ x: cx, y: p.y - 6, w: 8, h: 14, vy: -620 });
  }
  function useShrink(){
    if (state.shrinkCharges <= 0 || state.over || !state.running) return;
    state.shrinkCharges--; shrinkCountEl.textContent = state.shrinkCharges;
    state.effects.shrinkUntil = Math.max(state.effects.shrinkUntil, state.time) + 6;
  }

  function update(dt){
    state.time += dt;
    state.score += dt*10;
    scoreEl.textContent = Math.floor(state.score);
    state.difficulty = 1 + Math.min(2.2, state.time/24);

    const slowActive = state.effects.slowUntil > state.time;
    const worldDT = dt * (slowActive ? 0.55 : 1);
    state.player.scale = (state.effects.shrinkUntil > state.time) ? 0.6 : 1;

    const p = state.player, base = p.speed * state.difficulty * 0.95;
    let targetVX = 0;
    if(state.input.left) targetVX -= base;
    if(state.input.right) targetVX += base;
    targetVX += state.input.swipeVX;
    p.vx += (targetVX - p.vx) * Math.min(1, dt*10);
    p.x += p.vx * dt;
    const pw = p.w * p.scale, ph = p.h * p.scale;
    if (p.x < 0) { p.x = 0; p.vx = Math.max(0, p.vx); }
    if (p.x + pw > width) { p.x = width - pw; p.vx = Math.min(0, p.vx); }
    // keep player perched above bottom UI (accounts for shrink scaling)
    const floorY = height - uiBottom - ph - 10;
    p.y = Math.max(0, floorY);

    state.blockTimer -= worldDT;
    
    // ── Two-finger tap to pause ──────────────────────────────────────────────
const activeTouches = new Set();

canvas.addEventListener("pointerdown", (e)=>{
  if (e.pointerType === "touch") {
    activeTouches.add(e.pointerId);
    // if second finger lands during gameplay -> pause
    if (activeTouches.size >= 2 && state.running && !state.paused && !state.over) {
      togglePause();
    }
  }
});

["pointerup","pointercancel","pointerleave","pointerout"].forEach(ev=>{
  window.addEventListener(ev, (e)=>{
    if (e.pointerType === "touch") activeTouches.delete(e.pointerId);
  }, { passive:true });
});

// Keep your swipe handler, but only start swipe for single-finger drags
let swipeActive=false, swipeStartX=0;
canvas.addEventListener("pointerdown", e=>{
  if (e.pointerType === "touch" && activeTouches.size > 1) return; // ignore multi-touch
  swipeActive=true; swipeStartX=e.clientX;
});
// base interval grows ~8–10% to reduce spawn frequency slightly
const baseInterval = Math.max(0.24, 0.9 - state.time * 0.03);
const interval = baseInterval * 1.08; // bump to 1.10 for ~10% fewer spawns

if (state.blockTimer <= 0) {
  spawnBlock();
  // Step 2 (below) also reduces the “double-spawn” chance
  if (state.time > 12 && Math.random() < 0.25) spawnBlock();
  state.blockTimer = interval;
}

    // Power-ups (own cadence)
state.powTimer -= worldDT;
if (state.powTimer <= 0) {
  spawnPowerup();
  state.powTimer = rand(POWERUP_INTERVAL_MIN, POWERUP_INTERVAL_MAX);
}

// Coins (own cadence + chance)
state.coinTimer -= worldDT;
if (state.coinTimer <= 0) {
  if (Math.random() < COIN_CHANCE) spawnCoin();
  state.coinTimer = rand(COIN_INTERVAL_MIN, COIN_INTERVAL_MAX);
}

    for (let i=state.blocks.length-1; i>=0; i--) {
      const b = state.blocks[i]; b.y += b.vy * worldDT; if (b.y - b.h > height + 8) { state.blocks.splice(i,1); }
    }

    const magnet = state.effects.magnetUntil > state.time;
    for (let i=state.powerups.length-1; i>=0; i--) {
      const u = state.powerups[i];
      if (magnet) {
        const cx = (p.x + pw/2) - (u.x + u.w/2);
        const cy = (p.y + ph/2) - (u.y + u.h/2);
        const dist = Math.max(1, Math.hypot(cx, cy));
        u.x += (cx/dist) * 220 * worldDT; u.y += (cy/dist) * 220 * worldDT;
      } else { u.y += u.vy * worldDT; }
      if (u.y - u.h > height + 8) { state.powerups.splice(i,1); continue; }
      if (u.x < p.x + pw && u.x + u.w > p.x && u.y < p.y + ph && u.y + u.h > p.y) {
        if (u.type === "blaster") { state.ammo += 6; ammoEl.textContent = state.ammo; }
        else if (u.type === "shrink") { state.shrinkCharges += 1; shrinkCountEl.textContent = state.shrinkCharges; }
        else if (u.type === "shield") { state.effects.shieldUntil = Math.max(state.effects.shieldUntil, state.time) + 6; }
        else if (u.type === "slow")   { state.effects.slowUntil   = Math.max(state.effects.slowUntil,   state.time) + 6; }
        else if (u.type === "magnet") { state.effects.magnetUntil = Math.max(state.effects.magnetUntil, state.time) + 8; }
        else if (u.type === "life")   { state.lives = Math.min(5, state.lives + 1); renderHearts(); }
        state.powerups.splice(i,1);
      }
    }

    // coins (pickup) — no manual UI bump; Firestore snapshot updates the chip
    for (let i=state.coins.length-1; i>=0; i--) {
      const c = state.coins[i]; c.y += c.vy * worldDT;
      if (c.y - c.h > height + 8) { state.coins.splice(i,1); continue; }
      if (c.x < p.x + pw && c.x + c.w > p.x && c.y < p.y + ph && c.y + c.h > p.y) {
        state.coins.splice(i,1);
        window.firebase.addCoins(1).catch(()=>{});
      }
    }

    // bullets
    for (let i=state.bullets.length-1; i>=0; i--) {
      const bullet = state.bullets[i]; bullet.y += bullet.vy * dt;
      if (bullet.y + bullet.h < -10) { state.bullets.splice(i,1); continue; }
      for (let j=state.blocks.length-1; j>=0; j--) {
        const b = state.blocks[j];
        if (bullet.x < b.x + b.w && bullet.x + bullet.w > b.x && bullet.y < b.y + b.h && bullet.y + bullet.h > b.y) {
          state.blocks.splice(j,1); state.bullets.splice(i,1); state.score += 5; break;
        }
      }
    }

    // block vs player
    for (let i=state.blocks.length-1; i>=0; i--) {
      const b = state.blocks[i];
      const p2 = state.player, pw2 = p2.w*p2.scale, ph2 = p2.h*p2.scale;
      if (b.x < p2.x + pw2 && b.x + b.w > p2.x && b.y < p2.y + ph2 && b.y + b.h > p2.y) {
        if (state.player.invUntil > state.time) { state.blocks.splice(i,1); continue; }
        const shieldActive = state.effects.shieldUntil > state.time;
        if (shieldActive) { state.effects.shieldUntil = Math.max(state.time, state.effects.shieldUntil - 0.5); state.player.invUntil = state.time + 0.5; state.blocks.splice(i,1); continue; }
        if (state.lives > 0) {
  state.lives--;
  renderHearts();
  state.player.invUntil = state.time + 1.2;
  state.blocks.splice(i,1);
  continue;
}
        gameOver(); return;
      }
    }
  }

  function draw(){
    const g = ctx.createLinearGradient(0,0,0,height); g.addColorStop(0,"#0b1220"); g.addColorStop(1,"#0c0f14");
    ctx.fillStyle = g; ctx.fillRect(0,0,width,height);
    ctx.globalAlpha = 0.08; ctx.strokeStyle = "#8ab4ff"; ctx.lineWidth = 1;
    const grid = Math.max(20, Math.floor(Math.min(width, height)*0.04));
    ctx.beginPath(); for(let x=(width%grid); x<width; x+=grid){ ctx.moveTo(x,0); ctx.lineTo(x,height); }
    for(let y=(height%grid); y<height; y+=grid){ ctx.moveTo(0,y); ctx.lineTo(width,y); } ctx.stroke(); ctx.globalAlpha = 1;

    const p = state.player, pw = p.w*p.scale, ph = p.h*p.scale;

    if (state.effects.shieldUntil > state.time) {
      ctx.save(); ctx.globalAlpha = 0.25 + 0.15*Math.sin(state.time*8); ctx.fillStyle = "#4ade80";
      roundRect(ctx, p.x-6, p.y-6, pw+12, ph+12, Math.min(16, pw*0.35), true); ctx.restore();
    }
    if (state.player.invUntil > state.time) { ctx.globalAlpha = 0.6 + 0.4*Math.sin(state.time*30); }
    ctx.fillStyle = "#58a6ff"; roundRect(ctx, p.x, p.y, pw, ph, Math.min(10, pw*0.25), true); ctx.globalAlpha = 1;

    for (const b of state.blocks) {
      ctx.fillStyle = "#ff6b6b"; roundRect(ctx, b.x, b.y, b.w, b.h, Math.min(10, b.w*0.25), true);
      ctx.globalAlpha = 0.15; ctx.fillStyle = "#ffffff"; roundRect(ctx, b.x+b.w*0.1, b.y+b.h*0.08, b.w*0.8, b.h*0.18, 8, true); ctx.globalAlpha = 1;
    }

    // power-ups
    for (const u of state.powerups) {
      const r = Math.min(u.w, u.h);
      let bg = "#ffd166", glyph = "🔫";
      if (u.type === "shrink") { bg = "#60a5fa"; glyph = "✂"; }
      else if (u.type === "shield") { bg = "#4ade80"; glyph = "🛡"; }
      else if (u.type === "slow")   { bg = "#a78bfa"; glyph = "🐌"; }
      else if (u.type === "magnet") { bg = "#f472b6"; glyph = "🧲"; }
      else if (u.type === "life")   { bg = "#ef4444"; glyph = "❤️"; }
      ctx.fillStyle = bg;
      roundRect(ctx, u.x, u.y, u.w, u.h, Math.min(10, r * 0.25), true);
      ctx.font = `${Math.floor(r * 0.7)}px system-ui, apple color emoji, Segoe UI Emoji, Emoji`;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillStyle = "rgba(0,0,0,.85)";
      ctx.fillText(glyph, u.x + u.w / 2, u.y + u.h / 2 + 1);
    }

    // coins
    for (const c of state.coins) {
      const r = c.w/2, cx = c.x + r, cy = c.y + r;
      const grad = ctx.createRadialGradient(cx-r*0.4, cy-r*0.4, r*0.2, cx, cy, r);
      grad.addColorStop(0, "#ffe38a"); grad.addColorStop(0.55, "#f5c240"); grad.addColorStop(1, "#c68a12");
      ctx.fillStyle = grad; ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI*2); ctx.fill();
      ctx.strokeStyle = "rgba(0,0,0,.25)"; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(cx, cy, r-1, 0, Math.PI*2); ctx.stroke();
      ctx.save(); ctx.translate(cx,cy); ctx.fillStyle="rgba(0,0,0,.28)";
      for (let i=0;i<16;i++){ const a=i*(Math.PI*2/16); ctx.beginPath(); ctx.arc(Math.cos(a)*(r-3), Math.sin(a)*(r-3), 1.8, 0, Math.PI*2); ctx.fill(); }
      ctx.restore();
      ctx.beginPath(); ctx.arc(cx, cy, r*0.55, 0, Math.PI*2); ctx.fillStyle="rgba(0,0,0,.15)"; ctx.fill();
      ctx.fillStyle="#2b1900"; ctx.font=`${Math.max(10, r*0.9)}px system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial`; ctx.textAlign="center"; ctx.textBaseline="middle"; ctx.fillText("D", cx, cy+1);
    }

    // bullets
    ctx.fillStyle = "#f8fafc";
    for (const b of state.bullets) roundRect(ctx, b.x, b.y, b.w, b.h, 4, true);
  }

  function loop(now){
    if (!state.running || state.paused || state.over) return;
    const dt = Math.min(0.033, (now - state.last)/1000);
    state.last = now;
    update(dt); draw();
    requestAnimationFrame(loop);
  }

  draw();
})();
</script>
</body>
</html>